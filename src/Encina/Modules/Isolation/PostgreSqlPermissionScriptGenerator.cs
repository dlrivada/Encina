using System.Globalization;
using System.Text;

namespace Encina.Modules.Isolation;

/// <summary>
/// Generates PostgreSQL permission scripts for module isolation.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates PostgreSQL scripts that implement database-level module
/// isolation through schema separation and role-based permissions.
/// </para>
/// <para>
/// Generated scripts are idempotent using patterns like:
/// <list type="bullet">
/// <item><description>CREATE SCHEMA IF NOT EXISTS</description></item>
/// <item><description>DO blocks with exception handling for role creation</description></item>
/// <item><description>GRANT statements (which are inherently idempotent)</description></item>
/// <item><description>ALTER DEFAULT PRIVILEGES for future tables</description></item>
/// </list>
/// </para>
/// <para>
/// PostgreSQL uses roles instead of separate logins/users. Each module role has LOGIN
/// capability and can connect to the database directly.
/// </para>
/// <para>
/// Password placeholders use the format <c>{{ModuleName_Password}}</c> and must be
/// replaced with actual passwords before execution.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var generator = new PostgreSqlPermissionScriptGenerator();
/// var options = new ModuleIsolationOptions();
/// options.AddSharedSchemas("shared", "lookup");
/// options.AddModuleSchema(new ModuleSchemaOptions
/// {
///     ModuleName = "Orders",
///     SchemaName = "orders",
///     DatabaseUser = "orders_user"
/// });
///
/// var scripts = generator.GenerateAllScripts(options);
/// foreach (var script in scripts.OrderBy(s => s.Order))
/// {
///     Console.WriteLine($"-- {script.Name}");
///     Console.WriteLine(script.Content);
/// }
/// </code>
/// </example>
public sealed class PostgreSqlPermissionScriptGenerator : IModulePermissionScriptGenerator
{
    /// <inheritdoc />
    public string ProviderName => "PostgreSql";

    /// <inheritdoc />
    public PermissionScript GenerateSchemaCreationScript(ModuleIsolationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var sb = new StringBuilder();
        sb.AppendLine("-- PostgreSQL Schema Creation Script");
        sb.AppendLine("-- Generated by Encina Module Isolation");
        sb.AppendLine("-- This script is idempotent and can be run multiple times safely");
        sb.AppendLine();

        // Create shared schemas
        foreach (var schema in options.SharedSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            AppendSchemaCreation(sb, schema);
        }

        // Create module schemas
        foreach (var module in options.ModuleSchemas.OrderBy(m => m.ModuleName, StringComparer.OrdinalIgnoreCase))
        {
            AppendSchemaCreation(sb, module.SchemaName);
        }

        sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'Schema creation completed successfully.'; END $$;");

        return PermissionScript.ForSchemaCreation(sb.ToString());
    }

    /// <inheritdoc />
    public PermissionScript GenerateUserCreationScript(ModuleIsolationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var sb = new StringBuilder();
        sb.AppendLine("-- PostgreSQL Role Creation Script");
        sb.AppendLine("-- Generated by Encina Module Isolation");
        sb.AppendLine("-- IMPORTANT: Replace {{ModuleName_Password}} placeholders with actual passwords before execution");
        sb.AppendLine("-- This script is idempotent and can be run multiple times safely");
        sb.AppendLine();

        var modulesWithUsers = options.ModuleSchemas
            .Where(m => !string.IsNullOrWhiteSpace(m.DatabaseUser))
            .OrderBy(m => m.ModuleName, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (modulesWithUsers.Count == 0)
        {
            sb.AppendLine("-- No module roles configured");
            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'No module roles to create.'; END $$;");
        }
        else
        {
            foreach (var module in modulesWithUsers)
            {
                AppendRoleCreation(sb, module);
            }

            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'Role creation completed successfully.'; END $$;");
        }

        return PermissionScript.ForUserCreation(sb.ToString());
    }

    /// <inheritdoc />
    public PermissionScript GenerateGrantPermissionsScript(ModuleIsolationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var sb = new StringBuilder();
        sb.AppendLine("-- PostgreSQL Permission Grant Script");
        sb.AppendLine("-- Generated by Encina Module Isolation");
        sb.AppendLine("-- This script is idempotent and can be run multiple times safely");
        sb.AppendLine();

        var modulesWithUsers = options.ModuleSchemas
            .Where(m => !string.IsNullOrWhiteSpace(m.DatabaseUser))
            .OrderBy(m => m.ModuleName, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (modulesWithUsers.Count == 0)
        {
            sb.AppendLine("-- No module roles configured");
            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'No permissions to grant.'; END $$;");
        }
        else
        {
            foreach (var module in modulesWithUsers)
            {
                AppendModulePermissions(sb, module, options.SharedSchemas);
            }

            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'Permission grants completed successfully.'; END $$;");
        }

        return PermissionScript.ForGrantPermissions(sb.ToString());
    }

    /// <inheritdoc />
    public PermissionScript GenerateRevokePermissionsScript(ModuleIsolationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var sb = new StringBuilder();
        sb.AppendLine("-- PostgreSQL Permission Revoke Script");
        sb.AppendLine("-- Generated by Encina Module Isolation");
        sb.AppendLine("-- Use this script to clean up permissions before reconfiguring");
        sb.AppendLine("-- This script is idempotent and can be run multiple times safely");
        sb.AppendLine();

        var modulesWithUsers = options.ModuleSchemas
            .Where(m => !string.IsNullOrWhiteSpace(m.DatabaseUser))
            .OrderBy(m => m.ModuleName, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (modulesWithUsers.Count == 0)
        {
            sb.AppendLine("-- No module roles configured");
            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'No permissions to revoke.'; END $$;");
        }
        else
        {
            foreach (var module in modulesWithUsers)
            {
                AppendRevokePermissions(sb, module, options.SharedSchemas);
            }

            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'Permission revokes completed successfully.'; END $$;");
        }

        return PermissionScript.ForRevokePermissions(sb.ToString());
    }

    /// <inheritdoc />
    public IEnumerable<PermissionScript> GenerateAllScripts(ModuleIsolationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        yield return GenerateSchemaCreationScript(options);
        yield return GenerateUserCreationScript(options);
        yield return GenerateGrantPermissionsScript(options);
    }

    /// <inheritdoc />
    public PermissionScript GenerateModulePermissionsScript(
        ModuleSchemaOptions moduleOptions,
        IEnumerable<string> sharedSchemas)
    {
        ArgumentNullException.ThrowIfNull(moduleOptions);
        ArgumentNullException.ThrowIfNull(sharedSchemas);

        var sb = new StringBuilder();
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- PostgreSQL Permission Script for Module: {moduleOptions.ModuleName}");
        sb.AppendLine("-- Generated by Encina Module Isolation");
        sb.AppendLine();

        if (string.IsNullOrWhiteSpace(moduleOptions.DatabaseUser))
        {
            sb.AppendLine("-- No database role configured for this module");
            sb.AppendLine("DO $$ BEGIN RAISE NOTICE 'No permissions to configure - no database role specified.'; END $$;");
        }
        else
        {
            // Schema creation
            AppendSchemaCreation(sb, moduleOptions.SchemaName);

            // Role creation
            AppendRoleCreation(sb, moduleOptions);

            // Permissions
            var sharedSet = sharedSchemas.ToHashSet(StringComparer.OrdinalIgnoreCase);
            AppendModulePermissions(sb, moduleOptions, sharedSet);

            sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Module {moduleOptions.ModuleName} permissions configured successfully.'; END $$;");
        }

        return PermissionScript.ForModule(moduleOptions.ModuleName, sb.ToString());
    }

    /// <summary>
    /// Appends schema creation statement.
    /// </summary>
    private static void AppendSchemaCreation(StringBuilder sb, string schemaName)
    {
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Create schema: {schemaName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"CREATE SCHEMA IF NOT EXISTS {QuoteIdentifier(schemaName)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Ensured schema exists: {schemaName}'; END $$;");
        sb.AppendLine();
    }

    /// <summary>
    /// Appends role creation statement with LOGIN capability.
    /// </summary>
    private static void AppendRoleCreation(StringBuilder sb, ModuleSchemaOptions module)
    {
        var role = module.DatabaseUser!;
        var passwordPlaceholder = $"{{{{{module.ModuleName}_Password}}}}";

        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Create role for module: {module.ModuleName}");
        sb.AppendLine("DO $$");
        sb.AppendLine("BEGIN");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = '{EscapeSqlString(role)}') THEN");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        CREATE ROLE {QuoteIdentifier(role)} WITH LOGIN PASSWORD '{passwordPlaceholder}';");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        RAISE NOTICE 'Created role: {role}';");
        sb.AppendLine("    ELSE");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        RAISE NOTICE 'Role already exists: {role}';");
        sb.AppendLine("    END IF;");
        sb.AppendLine("END $$;");
        sb.AppendLine();
    }

    /// <summary>
    /// Appends permission grant statements for a module.
    /// </summary>
    private static void AppendModulePermissions(
        StringBuilder sb,
        ModuleSchemaOptions module,
        IReadOnlySet<string> sharedSchemas)
    {
        var role = module.DatabaseUser!;

        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Grant permissions for module: {module.ModuleName}");
        sb.AppendLine();

        // Full access to own schema
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Full access to module schema: {module.SchemaName}");

        // Grant USAGE on schema (required to access objects within)
        sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT USAGE ON SCHEMA {QuoteIdentifier(module.SchemaName)} TO {QuoteIdentifier(role)};");

        // Grant all privileges on existing tables
        sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA {QuoteIdentifier(module.SchemaName)} TO {QuoteIdentifier(role)};");

        // Grant execute on functions
        sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA {QuoteIdentifier(module.SchemaName)} TO {QuoteIdentifier(role)};");

        // Grant usage on sequences
        sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA {QuoteIdentifier(module.SchemaName)} TO {QuoteIdentifier(role)};");

        // ALTER DEFAULT PRIVILEGES for future objects
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Set default privileges for future tables in {module.SchemaName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} GRANT EXECUTE ON FUNCTIONS TO {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} GRANT USAGE, SELECT ON SEQUENCES TO {QuoteIdentifier(role)};");

        sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Granted full access on schema {module.SchemaName} to {role}'; END $$;");
        sb.AppendLine();

        // SELECT-only access to shared schemas
        foreach (var sharedSchema in sharedSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"-- Read-only access to shared schema: {sharedSchema}");
            sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT USAGE ON SCHEMA {QuoteIdentifier(sharedSchema)} TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT SELECT ON ALL TABLES IN SCHEMA {QuoteIdentifier(sharedSchema)} TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(sharedSchema)} GRANT SELECT ON TABLES TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Granted SELECT on schema {sharedSchema} to {role}'; END $$;");
        }

        if (sharedSchemas.Count > 0)
        {
            sb.AppendLine();
        }

        // SELECT-only access to additional allowed schemas
        foreach (var additionalSchema in module.AdditionalAllowedSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            // Skip if already in shared schemas
            if (sharedSchemas.Contains(additionalSchema))
            {
                continue;
            }

            sb.AppendLine(CultureInfo.InvariantCulture, $"-- Read-only access to additional schema: {additionalSchema}");
            sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT USAGE ON SCHEMA {QuoteIdentifier(additionalSchema)} TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"GRANT SELECT ON ALL TABLES IN SCHEMA {QuoteIdentifier(additionalSchema)} TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(additionalSchema)} GRANT SELECT ON TABLES TO {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Granted SELECT on schema {additionalSchema} to {role}'; END $$;");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Appends permission revoke statements for a module.
    /// </summary>
    private static void AppendRevokePermissions(
        StringBuilder sb,
        ModuleSchemaOptions module,
        IReadOnlySet<string> sharedSchemas)
    {
        var role = module.DatabaseUser!;

        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Revoke permissions for module: {module.ModuleName}");
        sb.AppendLine();

        // Revoke default privileges first (must be done before revoking schema permissions)
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Revoke default privileges in module schema: {module.SchemaName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLES FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} REVOKE EXECUTE ON FUNCTIONS FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(module.SchemaName)} REVOKE USAGE, SELECT ON SEQUENCES FROM {QuoteIdentifier(role)};");

        // Revoke from own schema
        sb.AppendLine(CultureInfo.InvariantCulture, $"-- Revoke from module schema: {module.SchemaName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE ALL ON ALL TABLES IN SCHEMA {QuoteIdentifier(module.SchemaName)} FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE ALL ON ALL FUNCTIONS IN SCHEMA {QuoteIdentifier(module.SchemaName)} FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE ALL ON ALL SEQUENCES IN SCHEMA {QuoteIdentifier(module.SchemaName)} FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE USAGE ON SCHEMA {QuoteIdentifier(module.SchemaName)} FROM {QuoteIdentifier(role)};");
        sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Revoked permissions on schema {module.SchemaName} from {role}'; END $$;");
        sb.AppendLine();

        // Revoke from shared schemas
        foreach (var sharedSchema in sharedSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(sharedSchema)} REVOKE SELECT ON TABLES FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE SELECT ON ALL TABLES IN SCHEMA {QuoteIdentifier(sharedSchema)} FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE USAGE ON SCHEMA {QuoteIdentifier(sharedSchema)} FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Revoked SELECT on schema {sharedSchema} from {role}'; END $$;");
        }

        // Revoke from additional allowed schemas
        foreach (var additionalSchema in module.AdditionalAllowedSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            if (sharedSchemas.Contains(additionalSchema))
            {
                continue;
            }

            sb.AppendLine(CultureInfo.InvariantCulture, $"ALTER DEFAULT PRIVILEGES IN SCHEMA {QuoteIdentifier(additionalSchema)} REVOKE SELECT ON TABLES FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE SELECT ON ALL TABLES IN SCHEMA {QuoteIdentifier(additionalSchema)} FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"REVOKE USAGE ON SCHEMA {QuoteIdentifier(additionalSchema)} FROM {QuoteIdentifier(role)};");
            sb.AppendLine(CultureInfo.InvariantCulture, $"DO $$ BEGIN RAISE NOTICE 'Revoked SELECT on schema {additionalSchema} from {role}'; END $$;");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Quotes an identifier for use in PostgreSQL statements.
    /// </summary>
    private static string QuoteIdentifier(string value)
    {
        // PostgreSQL uses double quotes for identifiers
        // Escape any double quotes within the identifier
        return $"\"{value.Replace("\"", "\"\"", StringComparison.Ordinal)}\"";
    }

    /// <summary>
    /// Escapes a string value for use in SQL statements.
    /// </summary>
    private static string EscapeSqlString(string value)
    {
        return value.Replace("'", "''", StringComparison.Ordinal);
    }
}

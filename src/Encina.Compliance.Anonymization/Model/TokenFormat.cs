namespace Encina.Compliance.Anonymization.Model;

/// <summary>
/// Defines the format of tokens generated by the tokenization service.
/// </summary>
/// <remarks>
/// <para>
/// Tokenization replaces sensitive values with non-sensitive substitutes (tokens)
/// while maintaining a reversible mapping. Unlike pseudonymization, tokens have
/// no mathematical relationship to the original value â€” the mapping is stored
/// in a <c>ITokenMappingStore</c>.
/// </para>
/// <para>
/// The token format affects storage requirements, readability, and compatibility
/// with existing systems that may validate field formats.
/// </para>
/// </remarks>
public enum TokenFormat
{
    /// <summary>
    /// Generate a UUID-based token (e.g., <c>"tok_a1b2c3d4-e5f6-7890-abcd-ef1234567890"</c>).
    /// </summary>
    /// <remarks>
    /// Standard format suitable for most use cases. Globally unique, fixed length (36 characters
    /// plus optional prefix). Uses <see cref="System.Guid.NewGuid"/> for generation.
    /// </remarks>
    Uuid = 0,

    /// <summary>
    /// Generate a token with a configurable prefix (e.g., <c>"usr_abc123"</c>, <c>"cc_xyz789"</c>).
    /// </summary>
    /// <remarks>
    /// Useful when tokens must be human-distinguishable by category. The prefix is configured
    /// via <see cref="TokenizationOptions.Prefix"/>. The suffix is a cryptographically random
    /// Base62 string for URL-safe storage.
    /// </remarks>
    Prefixed = 1,

    /// <summary>
    /// Generate a token that preserves the length and character classes of the original value.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Useful when downstream systems validate field formats (e.g., credit card numbers must
    /// be 16 digits, phone numbers must match a pattern). The token has the same length and
    /// uses the same character set (digits, letters, mixed) as the original value.
    /// </para>
    /// <para>
    /// <b>Note:</b> Format-preserving tokens provide weaker uniqueness guarantees than UUID tokens
    /// because the token space is constrained by the original value's format. Collisions are
    /// handled by the <c>ITokenMappingStore</c> with retry logic.
    /// </para>
    /// </remarks>
    FormatPreserving = 2
}

# December 2025 - Implementation History

This document captures the detailed implementation history for Encina during December 2025.

## Summary

December 2025 was a milestone month for Encina, with the project evolving from **SimpleMediator** to **Encina** and reaching **41 packages** at production status:

| Category | Packages | Tests |
|----------|----------|-------|
| Core & Validation | 5 | 524 |
| Web Integration | 2 | 52 |
| Serverless | 2 | 255 |
| Database Providers | 11 | 1,763 |
| Messaging Transports | 10 | - |
| Caching | 8 | 367 |
| Job Scheduling | 2 | 36 |
| Resilience | 3 | - |
| Event Sourcing | 1 | 16 |

**Total: 41 packages, 4,000+ tests**

> **Note**: 5 packages were deprecated:
> - Wolverine, NServiceBus, MassTransit, Dapr - overlapping concerns with Encina's messaging
> - EventStoreDB - Marten provides better .NET integration for Event Sourcing
>
> Code preserved in `.backup/deprecated-packages/`.

---

## Week 1: December 14-15 (Foundation)

### December 14 - Validation Satellite Packages

**Commits**: `21426b7`, `e8ae585`, `86bbee1`, `4595130`, `0b970b6`, `e50ad34`, `445f303`, `34ed3a3`, `3353c63`, `44853ef`

**IRequestContext Implementation**:
- Added `IRequestContext` interface for pipeline extensibility
- Implemented `RequestContext` with CorrelationId, UserId, TenantId, Metadata
- Added `IRequestContextAccessor` with AsyncLocal storage

**Validation Packages Created**:
- **SimpleMediator.FluentValidation**: Full FluentValidation integration with ROP
- **SimpleMediator.DataAnnotations**: Built-in .NET validation attributes
- **SimpleMediator.MiniValidator**: Ultra-lightweight validation (~20KB)
- **SimpleMediator.GuardClauses**: Defensive programming with Ardalis.GuardClauses

**Documentation**:
- Comprehensive READMEs for each validation package
- GuardClauses design analysis document
- Updated FEATURES_ROADMAP with validation status

---

## Week 2: December 17-18 (Database Providers)

### December 17 - Dapper & ADO.NET Providers

**Commits**: `457c3ad`, `5c85efa`, `85abaf0`

**Dapper Provider**:
- Created `SimpleMediator.Dapper` with all messaging patterns
- Implemented OutboxStore, InboxStore, SagaStore, ScheduledMessageStore
- Added test infrastructure with `SimpleMediator.Dapper.Tests`

**ADO.NET Provider**:
- Created `SimpleMediator.ADO` with pure ADO.NET implementation
- Same interface as Dapper, different implementation
- Zero ORM dependencies

### December 18 - Multi-Database Support

**Commits**: `f5e93a5`, `8fa9c40`, `87ad983`, `fd7c64b`, `e080250`, `15e7ae2`, `9d43bf8`, `6e7259f`, `cac590d`, `122a069`, `660581e`, `fc7d6e8`, `de05ce3`, `7efe416`, and many more

**Database Providers Added**:

| Database | Dapper Package | ADO.NET Package |
|----------|---------------|-----------------|
| SQL Server | SimpleMediator.Dapper.SqlServer | SimpleMediator.ADO.SqlServer |
| PostgreSQL | SimpleMediator.Dapper.PostgreSQL | SimpleMediator.ADO.PostgreSQL |
| MySQL/MariaDB | SimpleMediator.Dapper.MySQL | SimpleMediator.ADO.MySQL |
| SQLite | SimpleMediator.Dapper.Sqlite | SimpleMediator.ADO.Sqlite |
| Oracle | SimpleMediator.Dapper.Oracle | SimpleMediator.ADO.Oracle |

**SQL Dialect Translation**:
- Each provider implements dialect-specific SQL (TOP vs LIMIT, GETUTCDATE vs NOW, etc.)
- All providers share same interfaces from `SimpleMediator.Messaging`

**EntityFrameworkCore & AspNetCore**:
- Added `SimpleMediator.EntityFrameworkCore` with full messaging pattern support
- Added `SimpleMediator.AspNetCore` with middleware, authorization, Problem Details

**Infrastructure**:
- GitHub Actions workflow monitoring scripts
- SonarCloud workflow configuration
- Docker infrastructure for integration testing
- Stryker mutation testing configuration
- Standardized artifacts output paths

**Documentation**:
- Established MANDATORY 100% test coverage policy
- Unified tracking documents into single ROADMAP.md

---

## Week 3: December 19-20 (Testing & Observability)

### December 19 - OpenTelemetry & Stream Requests

**Commits**: `bbd8264`, `7954ddb`, `b501c38`, `01469f1`, `7b35ebe`, `9114592`, `0278cdc`, `34f8ac2`, and more

**OpenTelemetry Integration**:
- Created `SimpleMediator.OpenTelemetry` package
- `EncinaOpenTelemetryOptions` with ServiceName, ServiceVersion
- `MessagingActivityEnricher` for Outbox, Inbox, Sagas, Scheduling
- `MessagingEnricherPipelineBehavior<TRequest, TResponse>`
- Docker Compose observability stack (Jaeger, Prometheus, Loki, Grafana)

**Stream Requests**:
- Implemented `IStreamRequest<TItem>` interface
- `IStreamRequestHandler<TRequest, TItem>` interface
- `IStreamPipelineBehavior<TRequest, TItem>` interface
- `StreamPipelineBuilder<TRequest, TItem>` for pipeline construction
- `StreamDispatcher` for handler resolution and execution
- 98 tests passing

**Dapr Building Blocks**:
- Completed State Management, Bindings, Secrets building blocks
- (Later deprecated in Week 4)

**Comprehensive Test Suite**:
- Added 1,763 database provider tests
- Guard and Contract tests for Stream Requests (31 tests)
- Property, Integration and Load tests for Stream Requests (56 tests)
- Messaging pattern benchmarks (Outbox, Inbox, Infrastructure)

### December 20 - Test Coverage Expansion

**Commits**: `937d4a0`, `288fb9f`, `7c163dd`, `330c10c`, `15e6a34`, `21491cd`, `4cc699a`, `a1362d7`, `3c658fc`, `1e9de53`, `ef01d25`, and more

**Validation Test Coverage**:
- FluentValidation: 68 tests total
- DataAnnotations: 40% → 95% coverage
- MiniValidator: 40% → 95% coverage
- GuardClauses: 50% → 95% coverage

**Job Scheduling Tests**:
- Complete test project structure for Hangfire and Quartz
- Guard, Contract, Property, Integration, Load tests
- Job scheduling benchmarks for Quartz.NET
- Validation benchmarks comparing 4 validation approaches

**AspNetCore & EF Core Tests**:
- AspNetCore comprehensive test suite: 104 total tests
- EntityFrameworkCore comprehensive test suite: 100% coverage

**Resilience Packages**:
- Created `SimpleMediator.Extensions.Resilience`
- Created `SimpleMediator.Polly` with retry, circuit breaker, timeout
- Created `SimpleMediator.Refit` for HTTP client integration
- Complete test suite with 100% coverage

**Performance Benchmarks**:
- Provider comparison benchmarks (ADO.NET vs Dapper vs EF Core)
- Saga and Scheduling provider comparison benchmarks
- Custom FsCheck generators for property-based tests

**Crash Investigation**:
- Documented two issues identified during testing
- MSBuild stability issues with large solution

---

## Week 4: December 21 (Major Features)

### December 21 - Caching, Messaging, Event Sourcing

**Commits**: `fc276f2`, `89c7e3c`, `cf6377e`, `2b8646d`, `9271f19`, `8e5eb55`, `debdd0b`, `7e1acf3`, `9d95b83`, `f00fd59`, `b854bbe`, `34ed013`, `87adf91`, `c8403ae`, `eb88cd5`, `0af8316`, `cbdb6fb`, `6e0ac3b`, `a380937`, `e8e3578`

**Caching Infrastructure (8 packages)**:

| Package | Purpose | Tests |
|---------|---------|-------|
| SimpleMediator.Caching | Core abstractions | 49 |
| SimpleMediator.Caching.Memory | In-memory caching | 109 |
| SimpleMediator.Caching.Hybrid | Multi-tier (L1+L2) | 56 |
| SimpleMediator.Caching.Redis | StackExchange.Redis | - |
| SimpleMediator.Caching.Valkey | Open-source Redis | - |
| SimpleMediator.Caching.KeyDB | High-performance Redis fork | - |
| SimpleMediator.Caching.Dragonfly | Modern Redis-compatible | - |
| SimpleMediator.Caching.Garnet | Microsoft's Redis-compatible | - |

**Key Caching Features**:
- `ICacheProvider` abstraction for provider-agnostic caching
- `ICacheKeyGenerator` for consistent key generation
- `CachingPipelineBehavior<TRequest, TResponse>` for automatic query caching
- `[Cache]` attribute with configurable duration and key templates
- HybridCache integration for L1 (in-memory) + L2 (distributed) caching

**Messaging Transports (10 packages)**:

| Package | Technology | Version |
|---------|------------|---------|
| SimpleMediator.RabbitMQ | RabbitMQ.Client | 7.2.0 |
| SimpleMediator.AzureServiceBus | Azure.Messaging.ServiceBus | 7.20.1 |
| SimpleMediator.AmazonSQS | AWSSDK.SQS + SNS | 4.0.2.3 |
| SimpleMediator.Kafka | Confluent.Kafka | 2.12.0 |
| SimpleMediator.Redis.PubSub | StackExchange.Redis | 2.8.41 |
| SimpleMediator.InMemory | System.Threading.Channels | Built-in |
| SimpleMediator.NATS | NATS.Net | 2.6.11 |
| SimpleMediator.MQTT | MQTTnet | 5.0.1 |
| SimpleMediator.gRPC | Grpc.AspNetCore | 2.71.0 |
| SimpleMediator.GraphQL | HotChocolate | 15.1.11 |

**Event Sourcing**:
- Created `SimpleMediator.Marten` with Marten v8.0.0-beta-1
- Created `SimpleMediator.EventStoreDB` (later deprecated)
- `IAggregate` / `AggregateBase` abstractions
- `IAggregateRepository<TAggregate>` pattern
- `EventPublishingPipelineBehavior` for auto-publishing domain events

**Additional Features**:
- Parallel notification dispatch strategies (opt-in)
- Choreography-based saga abstractions (event-driven)
- MassTransit integration (later deprecated)
- Delegate cache optimization

**SignalR Integration**:
- Created `SimpleMediator.SignalR`
- `EncinaHub` base class for SignalR hubs
- `[BroadcastToSignalR]` attribute for declarative notification broadcasting
- `SignalRBroadcastHandler<T>` generic notification handler
- `ISignalRNotificationBroadcaster` service

**MongoDB Integration**:
- Created `SimpleMediator.MongoDB`
- `OutboxStoreMongoDB`, `InboxStoreMongoDB`, `SagaStoreMongoDB`, `ScheduledMessageStoreMongoDB`
- `MongoDbIndexCreator` for automatic index creation
- TTL indexes for inbox message cleanup

**LoggerMessage Source Generators**:
- Replaced all `ILogger.LogXxx()` with high-performance `LoggerMessage` source generators
- CA1848 compliance across all packages
- Zero-allocation logging in hot paths

---

## Week 5: December 22 (Renaming & Stabilization)

### December 22 - SimpleMediator → Encina

**Commits**: `cab5e04`, `2f86e28`, `b59f866`, `3e8df3b`, `14f429c`, `962e28d`, `589f5ca`, `c993620`, `f461883`, `e5732ba`, `f0c2565`, `c4e7f41`, `b375dc1`, `3eeef9b`, `0f84bef`, `10a2858`, `2cd1f0d`, `7577821`, `5cfab7c`, `b4339bc`, `f1ea1d0`, `63cdae7`, `4d4b29a`, `d900b81`, `1e9c86e`, `227647d`, `3638e6c`, `2532d03`, `5047426`, `972cf83`, `469085b`

**Major Renaming**:
- Renamed project from **SimpleMediator** to **Encina**
- Updated all namespaces, package names, and references
- Corrected error code case to lowercase (`encina.*` instead of `Encina.*`)
- Complete renaming cleanup across entire codebase

**License Change**:
- Changed license from proprietary to **MIT**

**GitHub Infrastructure**:
- Added GitHub Issue templates (bug_report, feature_request, technical_debt)
- Improved issue tracking workflow
- Added Known Issues section to CLAUDE.md

**Test Suite Fixes**:
- Comprehensive test suite fixes for validation behaviors
- Fixed namespace in SQLite IntegrationTests for CI filter
- Prevented duplicate behavior registration
- Skipped CLR-crashing load tests (Issue #5)
- Removed 10 obsolete skipped tests
- Registered IStreamRequestHandler and IStreamPipelineBehavior via assembly scanning

**CI/CD Improvements**:
- Excluded LoadTests/IntegrationTests from SonarCloud
- Temporarily excluded ContractTests/PropertyTests from SonarCloud (Issue #7)
- Added test filter for CI runs
- Fixed Quality Gate coverage and CI benchmark AOT errors

**Security Fixes**:
- Removed hardcoded passwords from configuration files
- Moved write permissions from workflow to job level

**Code Quality**:
- Suppressed Roslyn style warnings (IDE0008, IDE0058, IDE0160, IDE0011)
- Removed unnecessary usings
- Simplified outcome extraction and null handling
- Refactored loop variable declarations for consistency
- Added missing assertions to HybridCacheProvider tests (S2699)
- Resolved SonarCloud Medium Code Smells

---

## Week 6: December 23 (Orchestrator Pattern & CI Fixes)

### December 23 - Validation Orchestrator & Workflow Stabilization

**Commits**: `69389b0`, `c137e40`, `7d90827`, `bb17709`, `c9aebbe`, `d0b64a7`, `f0ebf3a`, `af9ad93`, `3cad5c4`, `5912e0f`, `05a4098`, `9123107`, `0967f02`, `e155d27`, `1db9031`, `3ee2327`, `634a0d4`, `bf86daf`, `f171f6d`, `7d579da`, `0adcc74`, `c854503`, `f9b515a`, `ef199ab`, `cf6cadb`, `fc36f4d`, `a2d0f61`, `8301a07`, `1fcca63`, `87d92a3`, `6a72163`, `c66625f`, `8b5b7e5`, `35b848f`, `8d85873`

**Validation Orchestrator Pattern**:

All validation packages now use the centralized Orchestrator pattern:

```
Encina (core)
├── Encina.Validation.IValidationProvider (interface)
├── Encina.Validation.ValidationOrchestrator (domain logic)
├── Encina.Validation.ValidationPipelineBehavior<,> (centralized behavior)
├── Encina.Validation.ValidationResult (immutable result)
└── Encina.Validation.ValidationError (record)

Encina.FluentValidation / DataAnnotations / MiniValidator
├── *ValidationProvider (implements IValidationProvider)
└── ServiceCollectionExtensions (registers orchestrator + provider)
```

**Messaging Orchestrator/Factory Architecture**:
- Created InboxOrchestrator, OutboxOrchestrator, SagaOrchestrator, SchedulerOrchestrator
- Added factory interfaces: IInboxMessageFactory, IOutboxMessageFactory, ISagaStateFactory, IScheduledMessageFactory
- Implemented factories for all 12 providers (Dapper x5, ADO x5, EF Core, MongoDB)
- Centralized InboxPipelineBehavior and OutboxPostProcessor in Encina.Messaging

**Security Fixes**:
- Added `SqlIdentifierValidator` to prevent SQL injection (S2077)
- All store files validate table names against safe regex pattern

**Deprecations**:
- Deprecated EventStoreDB (Marten provides better .NET integration)
- Deprecated Wolverine, NServiceBus, MassTransit, Dapr (overlapping concerns)
- Code preserved in `.backup/deprecated-packages/`

**CI/CD Fixes (Many Iterations)**:
- Fixed `InboxEfCoreBenchmarks.IterationSetup()` return type (async → sync)
- Added solution filters for messaging, resilience, event-sourcing, observability
- Added VSCode tasks.json with safe build/test configs
- Lowered coverage threshold to 50% until Phase 3 work
- Lower NBomber thresholds for GitHub Actions runners
- Lower load test thresholds for GitHub Actions runners
- Improved benchmark CSV parsing and mutation report path detection
- Optimized CI by splitting heavy tasks into separate workflows
- Configured SonarQubeTestProject to fix coverage detection
- Added FluentAssertions to Encina.Tests after removing from core

**Documentation**:
- Restructured ROADMAP with 6-phase development approach
- Documented Issue #5 as blocked by .NET 10 JIT bug
- Updated CHANGELOG with 2025-12-23 fixes
- Removed obsolete CA1848 suppressions after LoggerMessage migration
- Added comprehensive Saga patterns documentation
- Converted ASCII diagrams to Mermaid for GitHub rendering
- Added comprehensive Messaging Transports documentation

**SonarCloud Configuration**:
- Excluded intentional SQL dialect duplication from analysis
- Fixed test failures in PropertyTests and ContractTests
- Corrected ADO.Oracle and ADO.Sqlite SQL scripts syntax
- Resolved security hotspots and additional code smells

---

## Week 6: December 24 (Security & Documentation)

### December 24 - Security Hotspots & Documentation Cleanup

**Commits**: `ae9c376`, `4d7dc00`, `760e27c`, `e1c68db`, `19f2402`, `5a3c712`, `9090ed0`, `2b50a1e`, `29dead5`

**Security Hotspot Fixes**:

1. **DoS Prevention (S6444)** - Added regex timeout to prevent ReDoS attacks:
   - `Encina.Caching.Hybrid/HybridCacheProvider.cs`
   - `Encina.Caching.Memory/MemoryCacheProvider.cs`
   - `Encina.Caching.Memory/MemoryPubSubProvider.cs`
   - `Encina.GuardClauses/Guards.cs`
   - `Encina.SignalR/SignalRNotificationBroadcaster.cs`
   - Added `TimeSpan.FromSeconds(1)` to all Regex constructors

2. **SQL Injection False Positives (S2077)** - Configured SonarCloud suppressions:
   - All Dapper store files: `src/Encina.Dapper.*/**/*Store*.cs`
   - All ADO store files: `src/Encina.ADO.*/**/*Store*.cs`
   - Justification: `SqlIdentifierValidator.ValidateTableName()` validates table names

3. **RCE False Positives (S1523)** - Configured SonarCloud suppressions:
   - All SQL scripts: `src/**/Scripts/*.sql`
   - Justification: Static DDL scripts, no dynamic code injection

**Code Consolidation**:
- Centralized messaging patterns with shared `Log.cs` and `TransactionPipelineBehavior.cs`
- Reduced code duplication from ~11% to 1.7%

**Error Handling Improvements**:
- Refactored Encina error handling and validation guards
- Improved null handling in InboxOrchestrator response deserialization

**Documentation Cleanup**:
- Removed state/roadmap tracking from CLAUDE.md (moved to ROADMAP.md)
- CLAUDE.md now contains only stable AI instructions

---

## Technical Reference

### SQL Dialect Translation Matrix

| Feature | SQL Server | PostgreSQL | MySQL/MariaDB | SQLite | Oracle |
|---------|-----------|------------|---------------|--------|--------|
| UTC Timestamp | `GETUTCDATE()` | `NOW() AT TIME ZONE 'UTC'` | `UTC_TIMESTAMP()` | `datetime('now')` | `SYS_EXTRACT_UTC(SYSTIMESTAMP)` |
| Result Limit | `TOP N` | `LIMIT N` | `LIMIT N` | `LIMIT N` | `FETCH FIRST N ROWS ONLY` |
| GUID Type | `UNIQUEIDENTIFIER` | `UUID` | `CHAR(36)` | `TEXT` | `RAW(16)` or `VARCHAR2(36)` |
| Large Text | `NVARCHAR(MAX)` | `TEXT` | `TEXT` | `TEXT` | `CLOB` |
| DateTime | `DATETIME2(7)` | `TIMESTAMP` | `DATETIME(6)` | `TEXT (ISO8601)` | `TIMESTAMP` |
| Parameters | `@ParameterName` | `@ParameterName` | `@ParameterName` | `@ParameterName` | `:ParameterName` |

### Package Dependencies

**Database Providers**:
- SQL Server: `Microsoft.Data.SqlClient 6.1.3`
- PostgreSQL: `Npgsql 10.0.1`
- MySQL: `MySqlConnector 2.5.0`
- SQLite: `Microsoft.Data.Sqlite 10.0.1`
- Oracle: `Oracle.ManagedDataAccess.Core 23.26.0`

**Performance Comparison** (ADO.NET vs Dapper vs EF Core):
- ADO.NET: 63ms (baseline - fastest)
- Dapper: 100ms (1.59x slower)
- EF Core: 180ms (2.86x slower)

### Test Architecture

| Type | Dependencies | Database | Speed | Purpose |
|------|-------------|----------|-------|---------|
| Unit | Mocked | In-memory | <1ms | Isolated logic |
| Guards | N/A | N/A | <1ms | Parameter validation |
| Integration | Real | Testcontainers | 50-100ms | Real DB workflows |
| Property | Mocked | In-memory | <5ms | Invariants |
| Contract | Interface | In-memory | <10ms | API compliance |
| Load | Real | Testcontainers | Seconds | Concurrency/stress |

---

## Known Issues

### MSBuild Stability

Building the full solution can cause MSBuild crashes due to parallel execution overload with the large test suite (70+ projects).

**Mitigations**:
1. Use `-maxcpucount:1` flag for single-process builds
2. Use Solution Filters (.slnf) to build only what you need

### CLR Crash on .NET 10 (Issue #5)

Stream load tests cause CLR crash on .NET 10 due to JIT bug.

- **Upstream Bug**: [dotnet/runtime#121736](https://github.com/dotnet/runtime/issues/121736)
- **Status**: Fixed in .NET 11, awaiting .NET 10.x backport
- **Workaround**: Set `DOTNET_JitObjectStackAllocationConditionalEscape=0`

---

## Week 7: December 25-26 (Health Checks & Sagas)

### December 25 - Saga Timeout Support & ROP Extensions

**Issue Closed**: `#38` (Saga Timeout Support)

**Saga Timeout Implementation**:
- Added `TimeoutAtUtc` property to `ISagaState` interface
- Added `SagaStatus.TimedOut` status constant
- Added `SagaErrorCodes.Timeout` error code
- Implemented `TimeoutAsync()` method in `SagaOrchestrator`
- Implemented `GetExpiredSagasAsync()` method in `ISagaStore` and all implementations
- Added `StartAsync()` overload with timeout parameter
- Added `DefaultSagaTimeout` and `ExpiredSagaBatchSize` options in `SagaOptions`
- Full implementation across all providers (EF Core, Dapper, MongoDB, ADO.NET)

**ROP Assertion Extensions** (Encina.TestInfrastructure.Extensions):
- `ShouldBeSuccess()` / `ShouldBeRight()` - Assert Either is Right
- `ShouldBeError()` / `ShouldBeLeft()` - Assert Either is Left
- `ShouldBeBottom()` / `ShouldNotBeBottom()` - Assert Either default state
- `AllShouldBeSuccess()` / `AllShouldBeError()` - Collection assertions
- `ShouldContainSuccess()` / `ShouldContainError()` - Collection contains assertions
- `ShouldBeErrorWithCode()`, `ShouldBeValidationError()`, `ShouldBeAuthorizationError()` - EncinaError assertions
- Async variants: `ShouldBeSuccessAsync()`, `ShouldBeErrorAsync()`, `ShouldBeErrorWithCodeAsync()`

**Validation Guards**:
- Added unit tests for Request and Notification validation guards

### December 26 - Health Check Infrastructure (Issue #113)

**Issue Closed**: `#35` (Health Check Abstractions), `#113` (Automatic Provider Health Checks)

**Health Check Abstractions** (Encina.Messaging.Health):
- `IEncinaHealthCheck` interface for provider-agnostic health monitoring
- `HealthCheckResult` struct with `Healthy`/`Degraded`/`Unhealthy` status
- `EncinaHealthCheck` abstract base class with exception handling
- `OutboxHealthCheck` for monitoring pending outbox messages
- `InboxHealthCheck` for monitoring inbox processing state
- `SagaHealthCheck` for detecting stuck/expired sagas
- `SchedulingHealthCheck` for monitoring overdue scheduled messages
- Configurable warning/critical thresholds for all health checks
- `CompositeEncinaHealthCheck` for aggregating multiple health checks

**ASP.NET Core Integration** (Encina.AspNetCore.Health):
- `EncinaHealthCheckAdapter` for ASP.NET Core health check integration
- Extension methods: `AddEncinaHealthChecks()`, `AddEncinaOutbox()`, `AddEncinaInbox()`, `AddEncinaSaga()`, `AddEncinaScheduling()`
- Kubernetes readiness/liveness probe compatible

**Automatic Provider Health Checks**:
- `ProviderHealthCheckOptions` for configuring provider health checks (enabled by default)
- `DatabaseHealthCheck` abstract base class for database connectivity checks
- Opt-out via `config.ProviderHealthCheck.Enabled = false`

**Database Health Checks**:

| Provider | Package | Health Check |
|----------|---------|--------------|
| PostgreSQL | Encina.Dapper.PostgreSQL | `PostgreSqlHealthCheck` |
| MySQL | Encina.Dapper.MySQL | `MySqlHealthCheck` |
| SQL Server | Encina.Dapper.SqlServer | `SqlServerHealthCheck` |
| Oracle | Encina.Dapper.Oracle | `OracleHealthCheck` |
| SQLite | Encina.Dapper.Sqlite | `SqliteHealthCheck` |
| PostgreSQL | Encina.ADO.PostgreSQL | `PostgreSqlHealthCheck` |
| MySQL | Encina.ADO.MySQL | `MySqlHealthCheck` |
| SQL Server | Encina.ADO.SqlServer | `SqlServerHealthCheck` |
| Oracle | Encina.ADO.Oracle | `OracleHealthCheck` |
| SQLite | Encina.ADO.Sqlite | `SqliteHealthCheck` |
| EF Core | Encina.EntityFrameworkCore | `EntityFrameworkCoreHealthCheck` |

**Infrastructure Health Checks**:

| Provider | Package | Health Check |
|----------|---------|--------------|
| MongoDB | Encina.MongoDB | `MongoDbHealthCheck` |
| Redis/Valkey/KeyDB | Encina.Caching.Redis | `RedisHealthCheck` |
| RabbitMQ | Encina.RabbitMQ | `RabbitMQHealthCheck` |
| Kafka | Encina.Kafka | `KafkaHealthCheck` |
| Azure Service Bus | Encina.AzureServiceBus | `AzureServiceBusHealthCheck` |
| Amazon SQS | Encina.AmazonSQS | `AmazonSQSHealthCheck` |
| NATS | Encina.NATS | `NATSHealthCheck` |
| MQTT | Encina.MQTT | `MQTTHealthCheck` |
| Marten | Encina.Marten | `MartenHealthCheck` |
| Hangfire | Encina.Hangfire | `HangfireHealthCheck` |
| Quartz.NET | Encina.Quartz | `QuartzHealthCheck` |

**Saga Not Found Handler** (Issue #43):
- `IHandleSagaNotFound<TMessage>` interface for custom handling when saga correlation fails
- `SagaNotFoundContext` with `Ignore()` and `MoveToDeadLetterAsync()` actions
- `SagaNotFoundAction` enum (`None`, `Ignored`, `MovedToDeadLetter`)
- `ISagaNotFoundDispatcher` for invoking registered handlers
- `SagaErrorCodes.HandlerCancelled` and `SagaErrorCodes.HandlerFailed` error codes

**Modular Monolith Support** (Issue #57):
- `IModule` interface for defining application modules
- `IModuleLifecycle` interface for modules with startup/shutdown hooks
- `IModuleRegistry` for runtime module discovery and lookup
- `ModuleConfiguration` for fluent module registration
- `ModuleLifecycleHostedService` for automatic lifecycle management
- `AddEncinaModules()` extension method for service registration
- Automatic handler discovery from module assemblies
- Module ordering: start in registration order, stop in reverse (LIFO)

**Module Health Checks** (Issue #114):
- `IModuleWithHealthChecks` interface for modules to expose their own health checks
- `IModuleHealthCheck` interface for module-specific health checks with `ModuleName` property
- `AddEncinaModuleHealthChecks()` extension for registering all module health checks
- `AddEncinaModuleHealthChecks<TModule>()` for registering specific module health checks
- Automatic tagging with `encina`, `ready`, and `modules` tags
- Unit tests for all module health check functionality
- Updated Encina.AspNetCore README with module health check documentation

**Health Checks Integration Guide** (Issue #115):
- Created comprehensive guide at `docs/guides/health-checks.md`
- Covers integration with `AspNetCore.HealthChecks.*` ecosystem packages
- Examples for microservice and modular monolith architectures
- Kubernetes probes configuration (liveness, readiness, startup probes)
- Recommended NuGet packages table:
  - Databases: PostgreSQL, SQL Server, MySQL, Oracle, SQLite, MongoDB, CosmosDB, DynamoDB
  - Caching: Redis, Memcached
  - Message Brokers: RabbitMQ, Kafka, Azure Service Bus, AWS SQS
  - Cloud Services: Azure Storage, Key Vault, AWS S3
  - External Services: HTTP/URLs, gRPC, SignalR
- Health Check UI integration
- Best practices for health check organization and tagging
- Linked from Encina.AspNetCore README

**Breaking Changes**:
- `EncinaErrors.Create()` and `EncinaErrors.FromException()` `details` parameter changed from `object?` to `IReadOnlyDictionary<string, object?>?` (Issue #34)
- `EncinaErrorExtensions.GetDetails()` now returns `IReadOnlyDictionary<string, object?>` instead of `Option<object>`

**Integration Tests with Testcontainers**:
- Created fixtures: `MongoDbFixture`, `RabbitMqFixture`, `KafkaFixture`, `NatsFixture`, `RedisFixture`
- Integration test projects: MongoDB, RabbitMQ, Kafka, NATS, Marten
- 21 integration tests validating health checks against real infrastructure

**Issue #116 - EF Core PropertyTests Fix**:
- Removed obsolete FsCheck 2.x files (`Generators.cs`, `OutboxStoreEFFsCheckTests.cs`)
- Fixed `SagaStatus` type ambiguity in `SagaStoreEFPropertyTests.cs`
- Fixed `SagaStatus` type ambiguity in `SagaStoreEFIntegrationTests.cs`

**Health Check Documentation**:
- Updated README.md (main) with Health Checks overview section
- Updated Encina.EntityFrameworkCore/README.md with health check documentation
- Updated Encina.Dapper.PostgreSQL/README.md with health check documentation
- Updated Encina.Hangfire/README.md with health check documentation
- Updated Encina.Quartz/README.md with health check documentation

**Delegate Cache Optimization** (Issue #49):
- Optimized `ConcurrentDictionary` access patterns with TryGetValue-before-GetOrAdd
- Added `RequestKindCache` to avoid repeated `IsAssignableFrom` type checks
- Created `CacheOptimizationBenchmarks.cs` for performance validation
- Applied to both `RequestDispatcher` and `NotificationDispatcher`

**Recoverability Pipeline** (Issue #39):

Implemented a comprehensive two-phase retry strategy for transient error handling:

| Component | Purpose |
|-----------|---------|
| `RecoverabilityOptions` | Configuration for retry policies (immediate/delayed retries, backoff, jitter) |
| `IErrorClassifier` | Interface for classifying errors as Transient/Permanent/Unknown |
| `DefaultErrorClassifier` | Default implementation with exception type, HTTP status, and message pattern matching |
| `RecoverabilityContext` | Tracks retry state, attempt history, and creates `FailedMessage` for DLQ |
| `FailedMessage` | Record containing all context for dead letter queue handling |
| `RecoverabilityPipelineBehavior<,>` | Pipeline behavior implementing immediate retry logic |
| `IDelayedRetryScheduler` | Abstraction for scheduling delayed retries |
| `IDelayedRetryStore` | Persistence abstraction for delayed retry messages |
| `DelayedRetryProcessor` | BackgroundService for processing pending delayed retries |

**Retry Strategy**:
1. **Immediate Retries** (in-memory): 3 attempts with 100ms delay, exponential backoff
2. **Delayed Retries** (persistent): 30s → 5m → 30m → 2h with jitter (±20%)
3. **Dead Letter Queue**: `OnPermanentFailure` callback for DLQ integration

**Error Classification**:
- Exception types: `TimeoutException`, `HttpRequestException` (5xx) → Transient
- Exception types: `ArgumentException`, `ValidationException`, `HttpRequestException` (4xx) → Permanent
- Message patterns: "timeout", "connection", "temporary" → Transient

**Test Coverage**: 64 unit tests covering all recoverability scenarios.

**Pending Tests** (GitHub Issues created):
- Issue #117: Integration tests (blocked until `IDelayedRetryStore` implementation exists)
- Issue #118: Property-based tests for error classification
- Issue #119: Contract tests for Recoverability interfaces

**Test Coverage Final Status**:

| Type | Completed |
|------|:---------:|
| Unit Tests | 24/24 (100%) |
| Integration Tests | 17/17 (100%) |
| Property Tests | 24/24 (100%) |
| Contract Tests | 24/24 (100%) |

### December 26 (Continued) - AggregateTestBase (Issue #46)

**Issue Closed**: `#46` (AggregateTestBase - Given/When/Then for Event Sourcing)

**AggregateTestBase Implementation** (Encina.Testing.EventSourcing):

Base class for testing event-sourced aggregates using the Given/When/Then pattern:

```csharp
public class OrderAggregateTests : AggregateTestBase<Order, OrderId>
{
    [Fact]
    public void Submit_WhenOrderCreated_ShouldProduceOrderSubmittedEvent()
    {
        Given(
            new OrderCreated(OrderId, CustomerId, Items),
            new PaymentReceived(OrderId, Amount)
        );

        When(order => order.Submit());

        Then<OrderSubmitted>(e => Assert.Equal(OrderId, e.OrderId));

        ThenState(order => Assert.Equal(OrderStatus.Submitted, order.Status));
    }
}
```

**Features**:
- `AggregateTestBase<TAggregate, TId>` - Main base class for typed aggregate identifiers
- `AggregateTestBase<TAggregate>` - Convenience class for Guid identifiers
- `Given(params object[] events)` - Set up aggregate event history
- `GivenEmpty()` - Start with fresh aggregate (for creation tests)
- `When(Action<TAggregate>)` - Execute synchronous command
- `WhenAsync(Func<TAggregate, Task>)` - Execute asynchronous command
- `Then<TEvent>()` - Assert event was raised, returns event for further assertions
- `Then<TEvent>(Action<TEvent>)` - Assert and validate event
- `ThenEvents(params Type[])` - Verify exact event sequence
- `ThenNoEvents()` - Assert no events raised (idempotency tests)
- `ThenState(Action<TAggregate>)` - Assert aggregate state
- `ThenThrows<TException>()` - Assert exception was thrown
- `ThenThrows<TException>(Action<TException>)` - Assert and validate exception
- `GetUncommittedEvents()` - Direct access to uncommitted events
- `GetUncommittedEvents<TEvent>()` - Filtered access to specific event type
- `Aggregate` property - Access to aggregate after When()

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 30 | Core functionality coverage |
| Property Tests | 12 | FsCheck invariant verification |
| Contract Tests | 15 | Public API contract verification |
| Guard Clause Tests | 18 | Argument validation |
| **Total** | **75** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: N/A - Testing infrastructure, no external dependencies
- **Benchmarks**: N/A - Testing infrastructure, not performance-critical path
- **Load Tests**: N/A - Test helper class, not production code

**Dependencies Added**:
- `Encina.Testing.csproj` now references `Encina.Marten.csproj`
- Added FsCheck packages to `Encina.Testing.Tests.csproj`

### December 26 (Continued) - Automatic Rate Limiting (Issue #40)

**Issue Closed**: `#40` (Automatic Rate Limiting - detect outages and auto-throttle)

**Rate Limiting Implementation** (Encina.Polly):

Implemented adaptive rate limiting with automatic outage detection and throttling:

| Component | Purpose |
|-----------|---------|
| `RateLimitAttribute` | Configuration attribute for rate limiting policies |
| `IRateLimiter` | Interface for rate limiting operations |
| `AdaptiveRateLimiter` | Sliding window implementation with adaptive throttling |
| `RateLimitingPipelineBehavior<,>` | Pipeline behavior for automatic rate limiting |
| `RateLimitResult` | Result struct with allowed/denied status |
| `RateLimitState` | State enum (Normal, Throttled, Recovering) |

**RateLimitAttribute Configuration**:
- `MaxRequestsPerWindow` - Maximum requests allowed (default: 100)
- `WindowSizeSeconds` - Sliding window duration (default: 60)
- `ErrorThresholdPercent` - Error rate for throttling (default: 50%)
- `CooldownSeconds` - Duration in throttled state (default: 30)
- `RampUpFactor` - Capacity increase rate during recovery (default: 1.5x)
- `EnableAdaptiveThrottling` - Toggle adaptive behavior (default: true)
- `MinimumThroughputForThrottling` - Min requests before error rate applies (default: 10)

**State Machine**:
```
Normal → (error rate > threshold) → Throttled
Throttled → (cooldown expires) → Recovering
Recovering → (consecutive successes) → Normal
Recovering → (new errors) → Throttled
```

**Features**:
- Sliding window rate limiting algorithm
- Per-key state management with `ConcurrentDictionary`
- Automatic error rate tracking
- Gradual capacity recovery
- Thread-safe operations

**Usage Example**:
```csharp
[RateLimit(MaxRequestsPerWindow = 100, WindowSizeSeconds = 60)]
[RateLimit(ErrorThresholdPercent = 50, EnableAdaptiveThrottling = true)]
public record CallExternalApiQuery(string Url) : IRequest<ApiResponse>;
```

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 104 | Core functionality, all behaviors |
| Property Tests | 22 | FsCheck invariant verification |
| Contract Tests | 22 | Interface and API contracts |
| Guard Tests | 10 | Null argument validation |
| Load Tests | 4 | Concurrency and thread-safety |
| Benchmarks | 10 | Performance measurement |
| **Total** | **172** | Comprehensive coverage |

**Files Created**:
- `src/Encina.Polly/RateLimiting/RateLimitState.cs`
- `src/Encina.Polly/RateLimiting/RateLimitResult.cs`
- `src/Encina.Polly/RateLimiting/IRateLimiter.cs`
- `src/Encina.Polly/RateLimiting/AdaptiveRateLimiter.cs`
- `src/Encina.Polly/Attributes/RateLimitAttribute.cs`
- `src/Encina.Polly/Behaviors/RateLimitingPipelineBehavior.cs`
- `tests/Encina.Polly.Tests/RateLimitAttributeTests.cs`
- `tests/Encina.Polly.Tests/AdaptiveRateLimiterTests.cs`
- `tests/Encina.Polly.Tests/RateLimitingPipelineBehaviorTests.cs`
- `tests/Encina.Polly.PropertyTests/RateLimitingPropertyTests.cs`
- `tests/Encina.Polly.GuardTests/RateLimitingPipelineBehaviorGuardsTests.cs`
- `tests/Encina.Polly.GuardTests/AdaptiveRateLimiterGuardsTests.cs`
- `benchmarks/Encina.Polly.Benchmarks/RateLimitingBenchmarks.cs`

**Files Modified**:
- `src/Encina.Polly/ServiceCollectionExtensions.cs` - Added IRateLimiter and behavior registration
- `src/Encina/Errors/EncinaErrorCodes.cs` - Added RateLimitExceeded error code
- `src/Encina.Polly/PublicAPI.Unshipped.txt` - Added public API declarations
- `src/Encina/PublicAPI.Unshipped.txt` - Added error code declaration
- `tests/Encina.Polly.Tests/ServiceCollectionExtensionsTests.cs` - Updated for 3 behaviors
- `tests/Encina.Polly.ContractTests/BehaviorContractTests.cs` - Added rate limiting contracts
- `tests/Encina.Polly.LoadTests/ResilienceLoadTests.cs` - Added rate limiting load tests
- `benchmarks/Encina.Polly.Benchmarks/Program.cs` - Added benchmark runners

### December 26 (Continued) - Low-Ceremony Sagas (Issue #41)

**Issue Closed**: `#41` (Low-Ceremony Sagas - Wolverine-style minimal syntax)

**Low-Ceremony Sagas Implementation** (Encina.Messaging.Sagas.LowCeremony):

Implemented a fluent API for defining sagas inline without class inheritance:

| Component | Purpose |
|-----------|---------|
| `SagaDefinition` | Static factory class for creating saga definitions |
| `SagaDefinition<TData>` | Fluent builder for defining saga steps |
| `SagaStepBuilder<TData>` | Step configuration with Execute and Compensate |
| `SagaStepDefinition<TData>` | Immutable step configuration |
| `BuiltSagaDefinition<TData>` | Immutable saga definition ready for execution |
| `ISagaRunner` | Interface for executing saga definitions |
| `SagaRunner` | Implementation with full lifecycle management |
| `SagaResult<TData>` | Result record with SagaId, Data, and StepsExecuted |

**Usage Example**:
```csharp
var saga = SagaDefinition.Create<OrderData>("ProcessOrder")
    .Step("Reserve Inventory")
        .Execute(async (data, ct) =>
        {
            var result = await encina.Send(new ReserveInventory(data.OrderId), ct);
            return result.Map(r => data with { ReservationId = r.Id });
        })
        .Compensate(async (data, ct) =>
        {
            if (data.ReservationId.HasValue)
                await encina.Send(new CancelReservation(data.ReservationId.Value), ct);
        })
    .Step("Process Payment")
        .Execute(async (data, ct) =>
        {
            var result = await encina.Send(new ProcessPayment(data.OrderId), ct);
            return result.Map(r => data with { PaymentId = r.Id });
        })
        .Compensate(async (data, ct) =>
        {
            if (data.PaymentId.HasValue)
                await encina.Send(new RefundPayment(data.PaymentId.Value), ct);
        })
    .WithTimeout(TimeSpan.FromMinutes(5))
    .Build();

var result = await sagaRunner.RunAsync(saga, initialData);
```

**Features**:
- Fluent API without class inheritance required
- Sequential step execution with data flow between steps
- Automatic compensation in reverse order on failure
- Exception handling continues compensation for other steps
- Optional timeout configuration per saga
- Auto-generated step names when not specified
- Simplified overloads without `IRequestContext` parameter
- High-performance logging with `LoggerMessage` attributes
- Automatic DI registration when `UseSagas = true`

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 45 | SagaDefinition, SagaStepBuilder, SagaRunner |
| Property Tests | 11 | FsCheck invariant verification |
| Contract Tests | 8 | ISagaRunner interface contracts |
| **Total** | **64** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: Covered by unit tests with mocks - `SagaRunner` delegates to existing `SagaOrchestrator` which has its own integration tests
- **Guard Clause Tests**: Included in unit tests (45 tests)
- **Load Tests**: N/A - Thin wrapper over `SagaOrchestrator`, existing saga benchmarks cover performance
- **Benchmarks**: N/A - Minimal overhead, existing saga benchmarks in `SagaProviderComparisonBenchmarks.cs` cover performance

**Files Created**:
- `src/Encina.Messaging/Sagas/LowCeremony/SagaDefinition.cs`
- `src/Encina.Messaging/Sagas/LowCeremony/SagaStepBuilder.cs`
- `src/Encina.Messaging/Sagas/LowCeremony/ISagaRunner.cs`
- `src/Encina.Messaging/Sagas/LowCeremony/SagaRunner.cs`
- `tests/Encina.Tests/Sagas/LowCeremony/SagaDefinitionTests.cs`
- `tests/Encina.Tests/Sagas/LowCeremony/SagaStepBuilderTests.cs`
- `tests/Encina.Tests/Sagas/LowCeremony/SagaRunnerTests.cs`
- `tests/Encina.Messaging.PropertyTests/Sagas/LowCeremonySagaPropertyTests.cs`
- `tests/Encina.Messaging.ContractTests/Sagas/ISagaRunnerContractTests.cs`

**Files Modified**:
- `src/Encina.Messaging/MessagingServiceCollectionExtensions.cs` - Added ISagaRunner registration
- `src/Encina.Messaging/PublicAPI.Unshipped.txt` - Added public API declarations

### December 26 (Continued) - Dead Letter Queue (Issue #42)

**Issue Closed**: `#42` (Dead Letter Queue - unified abstraction across providers)

**Dead Letter Queue Implementation** (Encina.Messaging.DeadLetter):

Implemented a comprehensive Dead Letter Queue pattern for handling permanently failed messages:

| Component | Purpose |
|-----------|---------|
| `IDeadLetterMessage` | Interface for dead letter message abstraction |
| `IDeadLetterStore` | Provider-agnostic storage abstraction |
| `IDeadLetterMessageFactory` | Factory for creating messages from failed requests |
| `DeadLetterFilter` | Query filter with factory methods |
| `DeadLetterOptions` | Configuration with retention, cleanup, integration flags |
| `DeadLetterOrchestrator` | Core orchestration logic |
| `IDeadLetterManager` | High-level management API with replay capabilities |
| `DeadLetterManager` | Implementation with reflection-based replay |
| `DeadLetterHealthCheck` | Health check with warning/critical thresholds |
| `DeadLetterCleanupProcessor` | BackgroundService for automatic cleanup |

**IDeadLetterStore Interface**:
- `AddAsync(message)` - Add message to DLQ
- `GetAsync(messageId)` - Retrieve message by ID
- `GetMessagesAsync(filter, skip, take)` - Query with pagination
- `GetCountAsync(filter)` - Count matching messages
- `MarkAsReplayedAsync(messageId, result)` - Mark as replayed
- `DeleteAsync(messageId)` - Delete single message
- `DeleteExpiredAsync()` - Cleanup expired messages

**DeadLetterFilter Factory Methods**:
- `DeadLetterFilter.All` - Empty filter (returns all)
- `DeadLetterFilter.FromSource(pattern)` - Filter by source pattern
- `DeadLetterFilter.Since(dateTime)` - Filter by timestamp
- `DeadLetterFilter.ByCorrelationId(id)` - Filter by correlation

**DeadLetterOptions Configuration**:
- `RetentionPeriod` - How long to keep messages (default: 30 days)
- `CleanupInterval` - Background cleanup frequency (default: 1 hour)
- `EnableAutomaticCleanup` - Toggle cleanup processor
- `IntegrateWithRecoverability` - Auto-DLQ from recoverability failures
- `IntegrateWithOutbox` - Auto-DLQ from outbox failures
- `IntegrateWithInbox` - Auto-DLQ from inbox failures
- `IntegrateWithScheduling` - Auto-DLQ from scheduling failures
- `IntegrateWithSagas` - Auto-DLQ from saga failures
- `OnDeadLetter` - Callback for custom notifications

**IDeadLetterManager API**:
- `ReplayAsync(messageId)` - Replay single message through pipeline
- `ReplayAllAsync(filter, maxMessages)` - Batch replay with filter
- `GetMessageAsync(messageId)` - Get single message
- `GetMessagesAsync(filter, skip, take)` - Query messages
- `GetCountAsync(filter)` - Count messages
- `GetStatisticsAsync()` - Queue statistics by source
- `DeleteAsync(messageId)` - Delete message
- `DeleteAllAsync(filter)` - Bulk delete
- `CleanupExpiredAsync()` - Manual cleanup

**DeadLetterStatistics**:
- `TotalCount` - Total messages in DLQ
- `PendingCount` - Messages awaiting replay
- `ReplayedCount` - Successfully replayed messages
- `ExpiredCount` - Expired messages
- `CountBySource` - Breakdown by source pattern
- `OldestPendingAtUtc` / `NewestPendingAtUtc` - Timestamp range

**DeadLetterSourcePatterns Constants**:
- `Recoverability` - From recoverability pipeline failures
- `Outbox` - From outbox processing failures
- `Inbox` - From inbox processing failures
- `Scheduling` - From scheduled message failures
- `Saga` - From saga execution failures
- `Choreography` - From choreography-based saga failures

**DeadLetterHealthCheck**:
- Configurable `WarningThreshold` (default: 10 messages)
- Configurable `CriticalThreshold` (default: 100 messages)
- `OldMessageThreshold` for stale message detection
- Implements `EncinaHealthCheck` base class

**Usage Example**:
```csharp
// Configure DLQ
services.AddEncinaDeadLetterQueue<DeadLetterStoreEF, DeadLetterMessageFactoryEF>(options =>
{
    options.RetentionPeriod = TimeSpan.FromDays(30);
    options.EnableAutomaticCleanup = true;
    options.IntegrateWithRecoverability = true;
    options.OnDeadLetter = async (msg, ct) =>
        await alertService.SendAlertAsync($"Message dead-lettered: {msg.RequestType}");
});

// Query statistics
var stats = await manager.GetStatisticsAsync();
Console.WriteLine($"Total: {stats.TotalCount}, Pending: {stats.PendingCount}");
Console.WriteLine($"By source: {string.Join(", ", stats.CountBySource.Select(kv => $"{kv.Key}={kv.Value}"))}");

// Replay failed messages
var result = await manager.ReplayAsync(messageId);
if (result.IsRight)
    Console.WriteLine($"Replayed successfully at {result.RightToSeq().Head().ReplayedAtUtc}");

// Batch replay from specific source
var batchResult = await manager.ReplayAllAsync(
    DeadLetterFilter.FromSource(DeadLetterSourcePatterns.Recoverability),
    maxMessages: 50);
Console.WriteLine($"Replayed {batchResult.RightToSeq().Head().SuccessCount} of {batchResult.RightToSeq().Head().TotalProcessed}");
```

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 75 | Core functionality coverage |
| Integration Tests | 11 | End-to-end with DI container |
| Property Tests | 22 | FsCheck invariant verification |
| Contract Tests | 12 | IDeadLetterStore contract |
| **Total** | **120** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Guard Clause Tests**: N/A - Simple DTOs without explicit parameter validation
- **Load Tests**: N/A - DLQ is not a hot path (only handles permanently failed messages)
- **Benchmarks**: N/A - Performance depends on underlying store provider

**Files Created**:
- `src/Encina.Messaging/DeadLetter/IDeadLetterMessage.cs`
- `src/Encina.Messaging/DeadLetter/IDeadLetterStore.cs`
- `src/Encina.Messaging/DeadLetter/IDeadLetterMessageFactory.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterFilter.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterOptions.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterSourcePatterns.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterErrorCodes.cs`
- `src/Encina.Messaging/DeadLetter/IDeadLetterManager.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterOrchestrator.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterManager.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterLog.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterCleanupProcessor.cs`
- `src/Encina.Messaging/DeadLetter/DeadLetterServiceCollectionExtensions.cs`
- `src/Encina.Messaging/Health/DeadLetterHealthCheck.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterHealthCheckTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterOptionsTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterFilterTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterSourcePatternsTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterErrorCodesTests.cs`
- `tests/Encina.Tests/DeadLetter/ReplayResultTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterOrchestratorTests.cs`
- `tests/Encina.Tests/DeadLetter/DeadLetterManagerTests.cs`
- `tests/Encina.Tests/Integration/DeadLetterIntegrationTests.cs`
- `tests/Encina.Messaging.PropertyTests/DeadLetter/DeadLetterPropertyTests.cs`
- `tests/Encina.Messaging.ContractTests/DeadLetter/IDeadLetterStoreContractTests.cs`

**Files Modified**:
- `src/Encina.Messaging/MessagingConfiguration.cs` - Added `UseDeadLetterQueue` and `DeadLetterOptions`
- `src/Encina.Messaging/MessagingServiceCollectionExtensions.cs` - Added DeadLetter imports

### December 26 (Continued) - Bulkhead Isolation Pattern (Issue #53)

**Issue Closed**: `#53` (Bulkhead Isolation via Polly - limit concurrent operations)

**Bulkhead Isolation Implementation** (Encina.Polly):

Implemented bulkhead isolation pattern for limiting concurrent executions per handler type:

| Component | Purpose |
|-----------|---------|
| `BulkheadAttribute` | Configuration attribute for bulkhead policies |
| `IBulkheadManager` | Interface for bulkhead management operations |
| `BulkheadManager` | SemaphoreSlim-based implementation with per-key isolation |
| `BulkheadPipelineBehavior<,>` | Pipeline behavior for automatic enforcement |
| `BulkheadAcquireResult` | Result struct with acquisition status and releaser |
| `BulkheadMetrics` | Metrics struct with utilization calculations |
| `BulkheadRejectionReason` | Enum for rejection reasons |

**BulkheadAttribute Configuration**:
- `MaxConcurrency` - Maximum parallel executions (default: 10)
- `MaxQueuedActions` - Additional requests that can wait (default: 20)
- `QueueTimeoutMs` - Maximum wait time in queue (default: 30000ms)

**IBulkheadManager Interface**:
- `TryAcquireAsync(key, config, ct)` - Acquire permit with timeout and cancellation
- `GetMetrics(key)` - Get current metrics (concurrency, queue, rejection rate)
- `Reset(key)` - Reset bulkhead state

**BulkheadAcquireResult Factory Methods**:
- `Acquired(releaser, metrics)` - Successful acquisition
- `RejectedBulkheadFull(metrics)` - Both limits reached
- `RejectedQueueTimeout(metrics)` - Queue wait timeout
- `RejectedCancelled(metrics)` - Request cancelled

**BulkheadMetrics Calculated Properties**:
- `ConcurrencyUtilization` - Percentage of concurrency capacity in use
- `QueueUtilization` - Percentage of queue capacity in use
- `RejectionRate` - Total rejection rate as percentage

**Features**:
- Thread-safe `ConcurrentDictionary` for per-key bulkhead isolation
- `SemaphoreSlim` for efficient permit management
- Automatic permit release via `IDisposable` pattern
- `TimeProvider` injection for testability
- Logging with `LoggerMessage` source generators
- Automatic DI registration as singleton via `AddEncinaPolly()`

**Usage Example**:
```csharp
// Limit payment processing to 10 concurrent executions
[Bulkhead(MaxConcurrency = 10, MaxQueuedActions = 20)]
public record ProcessPaymentCommand(PaymentData Data) : ICommand<PaymentResult>;

// Limit external API calls with custom timeout
[Bulkhead(MaxConcurrency = 5, MaxQueuedActions = 10, QueueTimeoutMs = 5000)]
public record CallExternalApiQuery(string Endpoint) : IRequest<ApiResponse>;

// No queue - immediate rejection when concurrency limit reached
[Bulkhead(MaxConcurrency = 2, MaxQueuedActions = 0)]
public record CriticalResourceCommand(Guid Id) : ICommand<Unit>;
```

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 55 | BulkheadAttribute, BulkheadManager, BulkheadPipelineBehavior |
| Integration Tests | 3 | End-to-end with real pipeline |
| Property Tests | 6 | FsCheck invariant verification for metrics |
| Contract Tests | 20 | Interface and API contracts |
| Guard Tests | 7 | Null argument validation |
| Load Tests | 6 | Concurrency and thread-safety |
| Benchmarks | 8 | Performance measurement |
| **Total** | **105** | Comprehensive coverage |

**Files Created**:
- `src/Encina.Polly/Attributes/BulkheadAttribute.cs`
- `src/Encina.Polly/Bulkhead/IBulkheadManager.cs`
- `src/Encina.Polly/Bulkhead/BulkheadManager.cs`
- `src/Encina.Polly/Behaviors/BulkheadPipelineBehavior.cs`
- `tests/Encina.Polly.Tests/BulkheadAttributeTests.cs`
- `tests/Encina.Polly.Tests/BulkheadManagerTests.cs`
- `tests/Encina.Polly.Tests/BulkheadPipelineBehaviorTests.cs`
- `tests/Encina.Polly.GuardTests/BulkheadPipelineBehaviorGuardsTests.cs`
- `tests/Encina.Polly.GuardTests/BulkheadManagerGuardsTests.cs`
- `benchmarks/Encina.Polly.Benchmarks/BulkheadBenchmarks.cs`

**Files Modified**:
- `src/Encina.Polly/ServiceCollectionExtensions.cs` - Added IBulkheadManager and behavior registration
- `src/Encina.Polly/PublicAPI.Unshipped.txt` - Added public API declarations
- `tests/Encina.Polly.IntegrationTests/EndToEndIntegrationTests.cs` - Added bulkhead integration tests
- `tests/Encina.Polly.PropertyTests/AttributePropertyTests.cs` - Added bulkhead property tests
- `tests/Encina.Polly.ContractTests/BehaviorContractTests.cs` - Added bulkhead contract tests
- `tests/Encina.Polly.LoadTests/ResilienceLoadTests.cs` - Added bulkhead load tests

---

### December 26 (Continued) - Projections/Read Models (Issue #36)

**Issue Closed**: `#36` (Projections/Read Models - CQRS read side abstractions)

**Projection Abstractions** (Encina.Marten.Projections):

Full CQRS read side implementation with typed projection handlers and lifecycle management:

```csharp
// Define a read model
public class OrderSummary : IReadModel
{
    public Guid Id { get; set; }
    public string CustomerName { get; set; } = string.Empty;
    public decimal TotalAmount { get; set; }
    public int ItemCount { get; set; }
}

// Define a projection with multiple handlers
public class OrderSummaryProjection :
    IProjection<OrderSummary>,
    IProjectionCreator<OrderCreated, OrderSummary>,
    IProjectionHandler<OrderItemAdded, OrderSummary>,
    IProjectionDeleter<OrderCancelled, OrderSummary>
{
    public string ProjectionName => "OrderSummary";

    public OrderSummary Create(OrderCreated e, ProjectionContext ctx) =>
        new() { Id = ctx.StreamId, CustomerName = e.CustomerName };

    public OrderSummary Apply(OrderItemAdded e, OrderSummary m, ProjectionContext ctx) =>
        m with { TotalAmount = m.TotalAmount + e.Price * e.Quantity, ItemCount = m.ItemCount + e.Quantity };

    public bool ShouldDelete(OrderCancelled e, OrderSummary m, ProjectionContext ctx) => true;
}

// Register and configure
services.AddEncinaMarten(options => {
    options.Projections.EnableInlineProjections = true;
}).AddProjection<OrderSummaryProjection, OrderSummary>();
```

**Core Interfaces**:

| Interface | Purpose |
|-----------|---------|
| `IReadModel` | Marker interface with `Guid Id` property |
| `IReadModel<TId>` | Generic variant for strongly-typed identifiers |
| `IProjection<TReadModel>` | Base projection with `ProjectionName` |
| `IProjectionCreator<TEvent, TReadModel>` | Creates read model from initial event |
| `IProjectionHandler<TEvent, TReadModel>` | Applies event to existing read model |
| `IProjectionDeleter<TEvent, TReadModel>` | Conditionally deletes read model |

**Infrastructure Components**:

| Component | Purpose |
|-----------|---------|
| `ProjectionContext` | Event metadata (StreamId, SequenceNumber, Timestamp, etc.) |
| `ProjectionRegistry` | Registration and discovery of projections |
| `IReadModelRepository<T>` | CRUD operations for read models with ROP |
| `IProjectionManager` | Lifecycle and rebuild management |
| `IInlineProjectionDispatcher` | Synchronous projection updates |

**Marten Implementations**:

| Class | Purpose |
|-------|---------|
| `MartenReadModelRepository<T>` | Document storage via IDocumentSession |
| `MartenProjectionManager` | Event stream processing and rebuilds |
| `MartenInlineProjectionDispatcher` | Inline projection dispatch |

**Configuration Options**:

| Option | Default | Description |
|--------|---------|-------------|
| `EnableInlineProjections` | `false` | Enable synchronous projection updates |
| `RebuildOnStartup` | `false` | Rebuild all projections on startup |
| `DefaultBatchSize` | `1000` | Events per batch during rebuild |
| `MaxConcurrentRebuilds` | `1` | Parallel rebuilds allowed |
| `OnProjectionFaulted` | `null` | Callback for projection errors |

**Rebuild Options**:

| Option | Default | Description |
|--------|---------|-------------|
| `BatchSize` | `1000` | Events per batch |
| `DeleteExisting` | `true` | Delete existing read models before rebuild |
| `OnProgress` | `null` | Progress callback `(int percent, long events)` |
| `StartPosition` | `0` | Starting event position |
| `EndPosition` | `null` | Ending event position (null = latest) |
| `RunInBackground` | `false` | Run rebuild asynchronously |

**Projection States**:
- `Stopped`, `Starting`, `Running`, `CatchingUp`, `Rebuilding`, `Paused`, `Faulted`, `Stopping`

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 30 | Registry, Context, Status, Options, Handlers |
| Property Tests | 22 | FsCheck invariant verification |
| Contract Tests | 11 | Interface contracts and behaviors |
| Guard Tests | 17 | Null argument validation |
| **Total** | **80** | Comprehensive coverage |

**Load Tests/Benchmarks**: Not implemented. Justification: The projection code is primarily "glue code" that routes events to handlers and persists to Marten. The actual performance depends on Marten and PostgreSQL, not on our routing logic. Hot path optimization would not provide meaningful gains.

**Files Created**:
- `src/Encina.Marten/Projections/IReadModel.cs`
- `src/Encina.Marten/Projections/IProjection.cs`
- `src/Encina.Marten/Projections/ProjectionContext.cs`
- `src/Encina.Marten/Projections/IReadModelRepository.cs`
- `src/Encina.Marten/Projections/ProjectionErrorCodes.cs`
- `src/Encina.Marten/Projections/ProjectionStatus.cs`
- `src/Encina.Marten/Projections/IProjectionManager.cs`
- `src/Encina.Marten/Projections/MartenReadModelRepository.cs`
- `src/Encina.Marten/Projections/MartenProjectionManager.cs`
- `src/Encina.Marten/Projections/ProjectionLog.cs`
- `src/Encina.Marten/Projections/ProjectionRegistry.cs`
- `src/Encina.Marten/Projections/InlineProjectionDispatcher.cs`
- `src/Encina.Marten/Projections/ProjectionOptions.cs`
- `tests/Encina.Marten.Tests/Projections/TestReadModels.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionRegistryTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionContextTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionHandlerInfoTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionStatusTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionOptionsTests.cs`
- `tests/Encina.Marten.Tests/Projections/RebuildOptionsTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionPropertyTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionContractTests.cs`
- `tests/Encina.Marten.Tests/Projections/ProjectionGuardClauseTests.cs`

**Files Modified**:
- `src/Encina.Marten/EncinaMartenOptions.cs` - Added `Projections` property
- `src/Encina.Marten/ServiceCollectionExtensions.cs` - Added `AddProjection<,>()` method and `IProjectionRegistrar`

### December 26 (Continued) - Snapshotting for Large Aggregates (Issue #52)

**Issue Closed**: `#52` (Snapshotting for large aggregates - optimize loading of event-sourced aggregates)

**Snapshot Implementation** (Encina.Marten.Snapshots):

Implemented snapshotting pattern for optimizing large aggregate loading in event-sourced systems:

```csharp
// Enable snapshotting in options
services.AddEncinaMarten(options =>
{
    options.Snapshots.Enabled = true;
    options.Snapshots.SnapshotEvery = 100;
    options.Snapshots.KeepSnapshots = 3;

    // Per-aggregate configuration
    options.Snapshots.ConfigureAggregate<Order>(
        snapshotEvery: 50,
        keepSnapshots: 5);
});

// Register snapshotable aggregate
services.AddSnapshotableAggregate<Order>();

// Aggregate must implement marker interface
public class Order : AggregateBase, ISnapshotable<Order>
{
    // ... standard aggregate implementation
}
```

**Core Interfaces**:

| Interface | Purpose |
|-----------|---------|
| `ISnapshotable<TAggregate>` | Marker interface for aggregates supporting snapshots |
| `ISnapshot<TAggregate>` | Snapshot metadata (AggregateId, Version, CreatedAtUtc) |
| `ISnapshotStore<TAggregate>` | Storage abstraction with ROP error handling |

**Snapshot Classes**:

| Class | Purpose |
|-------|---------|
| `Snapshot<TAggregate>` | Immutable snapshot with aggregate state |
| `SnapshotEnvelope<TAggregate>` | Marten document wrapper for storage |
| `SnapshotOptions` | Global and per-aggregate configuration |
| `MartenSnapshotStore<TAggregate>` | Marten-based storage implementation |
| `SnapshotAwareAggregateRepository<TAggregate>` | Repository with snapshot optimization |

**SnapshotOptions Configuration**:

| Option | Default | Description |
|--------|---------|-------------|
| `Enabled` | `false` | Toggle snapshotting globally |
| `SnapshotEvery` | `100` | Event threshold for snapshot creation |
| `KeepSnapshots` | `3` | Retention limit (0 = keep all) |
| `AsyncSnapshotCreation` | `true` | Async vs sync snapshot creation |
| `ConfigureAggregate<T>()` | - | Per-aggregate overrides |

**ISnapshotStore Interface**:
- `SaveAsync(snapshot)` - Persist snapshot to storage
- `GetLatestAsync(aggregateId)` - Retrieve most recent snapshot
- `PruneAsync(aggregateId, keepCount)` - Remove old snapshots

**SnapshotAwareAggregateRepository Behavior**:
1. **Load**: Check for latest snapshot → Load snapshot if exists → Replay only events after snapshot version → Fall back to full event replay if no snapshot
2. **Save**: Save events → Check if version threshold reached → Create snapshot asynchronously → Prune old snapshots

**Error Codes** (SnapshotErrorCodes):
- `snapshot.load_failed` - Failed to load snapshot from storage
- `snapshot.save_failed` - Failed to persist snapshot
- `snapshot.prune_failed` - Failed to prune old snapshots
- `snapshot.invalid_state` - Invalid snapshot state detected

**Logging** (LoggerMessage, EventIds 100-159):
- High-performance logging via source generators
- Structured logging for debugging and monitoring

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 92 | Snapshot, SnapshotOptions, SnapshotEnvelope, MartenSnapshotStore, Repository |
| Property Tests | 11 | Theory-based invariant verification |
| Contract Tests | 8 | Interface behavior contracts |
| Guard Clause Tests | 12 | Null argument and range validation |
| Integration Tests | 6 | Real PostgreSQL with Testcontainers |
| **Total** | **129** | Comprehensive coverage |

**Load Tests/Benchmarks**: Not implemented. Justification:
1. Snapshotting is not a hot path (created every N events, not on every operation)
2. Main performance benefit is self-evident (snapshot + few events < replaying 1000+ events)
3. Actual storage performance depends on Marten/PostgreSQL, not our code
4. Pre-1.0 focus on design quality over micro-optimizations

**Files Created**:
- `src/Encina.Marten/Snapshots/ISnapshotable.cs`
- `src/Encina.Marten/Snapshots/ISnapshot.cs`
- `src/Encina.Marten/Snapshots/ISnapshotStore.cs`
- `src/Encina.Marten/Snapshots/SnapshotOptions.cs`
- `src/Encina.Marten/Snapshots/SnapshotErrorCodes.cs`
- `src/Encina.Marten/Snapshots/MartenSnapshotStore.cs`
- `src/Encina.Marten/Snapshots/SnapshotEnvelope.cs`
- `src/Encina.Marten/Snapshots/SnapshotLog.cs`
- `src/Encina.Marten/Snapshots/SnapshotAwareAggregateRepository.cs`
- `tests/Encina.Marten.Tests/Snapshots/TestSnapshotableAggregate.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotOptionsTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotEnvelopeTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotErrorCodesTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/MartenSnapshotStoreTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotServiceCollectionTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotPropertyTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotContractTests.cs`
- `tests/Encina.Marten.Tests/Snapshots/SnapshotGuardClauseTests.cs`
- `tests/Encina.Marten.IntegrationTests/Snapshots/TestSnapshotableAggregate.cs`
- `tests/Encina.Marten.IntegrationTests/Snapshots/MartenSnapshotStoreIntegrationTests.cs`

**Files Modified**:
- `src/Encina.Marten/EncinaMartenOptions.cs` - Added `Snapshots` property
- `src/Encina.Marten/ServiceCollectionExtensions.cs` - Added `AddSnapshotableAggregate<T>()` method
- `tests/Encina.Marten.IntegrationTests/Encina.Marten.IntegrationTests.csproj` - Added NSubstitute reference

### December 26 (Continued) - Event Versioning (Issue #37)

**Issue Closed**: `#37` (Event Versioning - Upcasters for schema evolution)

**Event Versioning Implementation** (Encina.Marten.Versioning):

Implemented comprehensive event versioning/upcasting system for handling schema evolution in event-sourced systems:

```csharp
// Define an upcaster class
public class ProductCreatedV1ToV2Upcaster
    : EventUpcaster<ProductCreatedV1, ProductCreatedV2>,
      IEventUpcaster<ProductCreatedV1, ProductCreatedV2>
{
    public override string EventTypeName => nameof(ProductCreatedV1);
    public string SourceEventTypeName => nameof(ProductCreatedV1);
    public Type SourceEventType => typeof(ProductCreatedV1);
    public Type TargetEventType => typeof(ProductCreatedV2);

    protected override ProductCreatedV2 Upcast(ProductCreatedV1 oldEvent) =>
        new(oldEvent.ProductId, oldEvent.Name, Price: 0m);

    ProductCreatedV2 IEventUpcaster<ProductCreatedV1, ProductCreatedV2>.Upcast(ProductCreatedV1 oldEvent) =>
        Upcast(oldEvent);
}

// Or use inline lambda syntax
options.EventVersioning.AddUpcaster<OrderCreatedV1, OrderCreatedV2>(
    old => new OrderCreatedV2(old.OrderId, old.CustomerName, "unknown@example.com"));

// Configure via EncinaMartenOptions
services.AddEncinaMarten(options =>
{
    options.EventVersioning
        .AddUpcaster<ProductCreatedV1ToV2Upcaster>()
        .ScanAssembly(typeof(ProductCreatedV1ToV2Upcaster).Assembly);
});
```

**Core Interfaces**:

| Interface | Purpose |
|-----------|---------|
| `IEventUpcaster` | Base interface with source event type name |
| `IEventUpcaster<TFrom, TTo>` | Strongly-typed upcaster with transformation method |

**Infrastructure Components**:

| Component | Purpose |
|-----------|---------|
| `EventUpcasterBase` | Abstract base wrapping Marten's `EventUpcaster<TFrom, TTo>` |
| `LambdaEventUpcaster<TFrom, TTo>` | Lambda-based upcaster for inline definitions |
| `EventUpcasterRegistry` | Registration and discovery of upcasters |
| `EventVersioningOptions` | Fluent configuration API |
| `ConfigureMartenEventVersioning` | `IConfigureOptions<StoreOptions>` integration |
| `VersioningLog` | High-performance logging with `LoggerMessage` |

**EventUpcasterRegistry Methods**:
- `Register<TUpcaster>()` - Register an upcaster by type
- `ScanAndRegister(assembly)` - Scan assembly for upcasters
- `HasUpcasterFor(eventTypeName)` - Check if upcaster exists
- `GetAllUpcasters()` - Get all registered upcasters
- `Count` - Number of registered upcasters

**EventVersioningOptions Fluent API**:
- `AddUpcaster<TUpcaster>()` - Add class-based upcaster
- `AddUpcaster<TFrom, TTo>(Func<TFrom, TTo>)` - Add lambda upcaster
- `ScanAssembly(assembly)` - Scan assembly for upcasters
- `ApplyTo(registry)` - Apply configuration to registry

**Error Codes** (EventVersioningErrorCodes):
- `event.versioning.upcast_failed` - Upcasting operation failed
- `event.versioning.upcaster_not_found` - No upcaster for event type
- `event.versioning.registration_failed` - Failed to register upcaster
- `event.versioning.duplicate_upcaster` - Duplicate upcaster registration
- `event.versioning.invalid_configuration` - Invalid configuration

**Logging** (LoggerMessage, EventIds 100-129):
- `ConfiguringMartenUpcasters` (100) - Start of configuration
- `AddingUpcasterToMarten` (101) - Individual upcaster registration
- `EventVersioningEnabled` (102) - Configuration complete

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 23 | Registry, Options, Lambda, ErrorCodes, Base |
| Property Tests | 3 | FsCheck invariant verification |
| Contract Tests | 4 | Interface behavior contracts |
| Guard Clause Tests | 5 | Null argument validation |
| Integration Tests | 6 | Real PostgreSQL with Testcontainers |
| **Total** | **41** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Load Tests/Benchmarks**: N/A - Upcasting is done during event deserialization (Marten's responsibility). Our code is thin wrapper with minimal overhead. The actual performance depends on Marten, not our routing code.

**Files Created**:
- `src/Encina.Marten/Versioning/ConfigureMartenEventVersioning.cs`
- `src/Encina.Marten/Versioning/VersioningLog.cs`
- `tests/Encina.Marten.Tests/Versioning/TestEvents.cs`
- `tests/Encina.Marten.Tests/Versioning/TestUpcasters.cs`
- `tests/Encina.Marten.Tests/Versioning/EventUpcasterBaseTests.cs`
- `tests/Encina.Marten.Tests/Versioning/EventUpcasterRegistryTests.cs`
- `tests/Encina.Marten.Tests/Versioning/EventVersioningOptionsTests.cs`
- `tests/Encina.Marten.Tests/Versioning/LambdaEventUpcasterTests.cs`
- `tests/Encina.Marten.Tests/Versioning/EventVersioningErrorCodesTests.cs`
- `tests/Encina.Marten.Tests/Versioning/VersioningGuardClauseTests.cs`
- `tests/Encina.Marten.Tests/Versioning/VersioningContractTests.cs`
- `tests/Encina.Marten.Tests/Versioning/VersioningPropertyTests.cs`
- `tests/Encina.Marten.IntegrationTests/Versioning/TestVersionedEvents.cs`
- `tests/Encina.Marten.IntegrationTests/Versioning/TestProductUpcasters.cs`
- `tests/Encina.Marten.IntegrationTests/Versioning/EventVersioningIntegrationTests.cs`

**Files Modified**:
- `src/Encina.Marten/ServiceCollectionExtensions.cs` - Added `IEventUpcasterRegistrar` interface and DI registration
- `src/Encina.Marten/EncinaMartenOptions.cs` - Added `EventVersioning` property (already existed)
- `src/Encina.Marten/PublicAPI.Unshipped.txt` - Added public API declarations

### December 26 (Continued) - Routing Slip Pattern (Issue #62)

**Issue Closed**: `#62` (Routing Slip Pattern - Dynamic message routing with compensation)

**Routing Slip Implementation** (Encina.Messaging.RoutingSlip):

Implemented the Routing Slip enterprise integration pattern for dynamic message routing with inline step definition and automatic compensation:

```csharp
var definition = RoutingSlipBuilder.Create<OrderData>("ProcessOrder")
    .Step("Validate Order")
        .Execute((data, ctx, ct) =>
        {
            // Validate order, dynamically add verification if needed
            if (data.Amount > 10000)
                ctx.AddStepNext(manualApprovalStep);
            return ValueTask.FromResult(Right<EncinaError, OrderData>(data));
        })
    .Step("Process Payment")
        .Execute(async (data, ctx, ct) =>
        {
            data.PaymentId = await ProcessPaymentAsync(data);
            return Right<EncinaError, OrderData>(data);
        })
        .Compensate(async (data, ctx, ct) =>
            await RefundPaymentAsync(data.PaymentId))
    .Step("Ship Order")
        .Execute(async (data, ctx, ct) =>
        {
            data.TrackingNumber = await ShipAsync(data);
            return Right<EncinaError, OrderData>(data);
        })
        .Compensate(async (data, ctx, ct) =>
            await CancelShipmentAsync(data.TrackingNumber))
    .OnCompletion(async (data, ctx, ct) =>
        await NotifyCustomerAsync(data))
    .WithTimeout(TimeSpan.FromMinutes(5))
    .Build();

var result = await runner.RunAsync(definition, new OrderData());
// result.FinalData.TrackingNumber, result.StepsExecuted, result.StepsAdded
```

**Core Interfaces**:

| Interface | Purpose |
|-----------|---------|
| `IRoutingSlipRunner` | Executes routing slip definitions |

**Infrastructure Components**:

| Component | Purpose |
|-----------|---------|
| `RoutingSlipBuilder` | Static factory and fluent API entry point |
| `RoutingSlipBuilder<TData>` | Generic builder with step configuration |
| `RoutingSlipStepBuilder<TData>` | Step configuration with Execute/Compensate |
| `BuiltRoutingSlipDefinition<TData>` | Immutable definition ready for execution |
| `RoutingSlipStepDefinition<TData>` | Single step in the itinerary |
| `RoutingSlipContext<TData>` | Context for dynamic route modification |
| `RoutingSlipActivityEntry<TData>` | Activity log entry with compensation data |
| `RoutingSlipResult<TData>` | Execution result with metrics |
| `RoutingSlipRunner` | Full runner implementation |
| `RoutingSlipOptions` | Configuration options |

**Dynamic Route Modification** (via RoutingSlipContext):
- `AddStep(step)` - Add step to end of itinerary
- `AddStepNext(step)` - Insert step immediately after current
- `InsertStep(index, step)` - Insert at specific position
- `RemoveStepAt(index)` - Remove step at position
- `ClearRemainingSteps()` - Terminate early

**RoutingSlipResult Metrics**:
- `RoutingSlipId` - Unique execution identifier
- `FinalData` - Data after all steps executed
- `StepsExecuted` - Total steps executed
- `StepsAdded` - Steps dynamically added during execution
- `StepsRemoved` - Steps skipped or removed
- `Duration` - Total execution time
- `ActivityLog` - Full activity log for audit/debugging

**Configuration Options**:

| Option | Default | Description |
|--------|---------|-------------|
| `DefaultTimeout` | 30 min | Default timeout for routing slips |
| `StuckCheckInterval` | 5 min | Interval for stuck slip detection |
| `StuckThreshold` | 10 min | Time after which slip is considered stuck |
| `BatchSize` | 100 | Max slips per processing batch |
| `ContinueCompensationOnFailure` | true | Continue with other compensations if one fails |

**Error Codes** (RoutingSlipErrorCodes):
- `routingslip.not_found` - Routing slip not found
- `routingslip.invalid_status` - Invalid status for operation
- `routingslip.step_failed` - Step execution failed
- `routingslip.compensation_failed` - Compensation failed
- `routingslip.timeout` - Execution timed out
- `routingslip.handler.cancelled` - Handler was cancelled
- `routingslip.handler.failed` - Handler threw exception

**Status Constants** (RoutingSlipStatus):
- `Running`, `Completed`, `Compensating`, `Compensated`, `Failed`, `TimedOut`

**Comparison with Saga Pattern**:

| Aspect | Saga (Issue #41) | Routing Slip (Issue #62) |
|--------|-----------------|--------------------------|
| Route Definition | Fixed at build time | Can change during execution |
| Step Addition | Not possible | `AddStep()`, `AddStepNext()`, `InsertStep()` |
| Step Removal | Not possible | `RemoveStepAt()`, `ClearRemainingSteps()` |
| Use Case | Predefined workflows | Dynamic, adaptive workflows |
| Persistence | Via `ISagaStore` | In-memory (store abstraction available) |

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 74 | Builder, StepBuilder, Runner, Context |
| Property Tests | 63 | FsCheck invariant verification |
| Guard Clause Tests | 35 | Null argument and range validation |
| **Total** | **137** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: N/A - RoutingSlip is primarily in-memory execution. There's no database/external dependency. The `IRoutingSlipStore` is an optional persistence abstraction not yet implemented.
- **Contract Tests**: N/A - `IRoutingSlipRunner` is the only public interface, covered by unit tests.
- **Load Tests/Benchmarks**: N/A - Performance depends entirely on user-provided step functions, not the routing infrastructure. The pattern is about workflow composition, not hot-path performance.

**Files Created**:
- `src/Encina.Messaging/RoutingSlip/RoutingSlipErrorCodes.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipStatus.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipOptions.cs`
- `src/Encina.Messaging/RoutingSlip/IRoutingSlipState.cs`
- `src/Encina.Messaging/RoutingSlip/IRoutingSlipStore.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipContext.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipStepDefinition.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipActivityEntry.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipResult.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipBuilder.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipStepBuilder.cs`
- `src/Encina.Messaging/RoutingSlip/IRoutingSlipRunner.cs`
- `src/Encina.Messaging/RoutingSlip/RoutingSlipRunner.cs`
- `tests/Encina.Tests/RoutingSlip/RoutingSlipBuilderTests.cs`
- `tests/Encina.Tests/RoutingSlip/RoutingSlipStepBuilderTests.cs`
- `tests/Encina.Tests/RoutingSlip/RoutingSlipRunnerTests.cs`
- `tests/Encina.Tests/RoutingSlip/RoutingSlipContextTests.cs`
- `tests/Encina.Tests/PropertyTests/RoutingSlipPropertyTests.cs`
- `tests/Encina.Tests/Guards/RoutingSlipGuardsTests.cs`

**Files Modified**:
- `src/Encina.Messaging/MessagingConfiguration.cs` - Added `UseRoutingSlips` and `RoutingSlipOptions`
- `src/Encina.Messaging/MessagingServiceCollectionExtensions.cs` - Added `IRoutingSlipRunner` registration
- `src/Encina.Messaging/PublicAPI.Unshipped.txt` - Added public API declarations

---

### December 27 - Azure Functions Integration (Issue #59)

**Issue Closed**: `#59` (Azure Functions Integration - Serverless function execution)

**Azure Functions Implementation** (Encina.AzureFunctions):

Implemented comprehensive Azure Functions integration for serverless execution with full Railway Oriented Programming support:

```csharp
// Program.cs configuration
var host = new HostBuilder()
    .ConfigureFunctionsWorkerDefaults(builder =>
    {
        builder.UseEncinaMiddleware();
    })
    .ConfigureServices(services =>
    {
        services.AddEncina(typeof(Program).Assembly);
        services.AddEncinaAzureFunctions(options =>
        {
            options.CorrelationIdHeader = "X-Request-ID";
            options.EnableRequestContextEnrichment = true;
        });
    })
    .Build();

// HTTP Trigger function
[Function("CreateOrder")]
public async Task<HttpResponseData> CreateOrder(
    [HttpTrigger(AuthorizationLevel.Function, "post", Route = "orders")]
    HttpRequestData req)
{
    var command = await req.ReadFromJsonAsync<CreateOrder>();
    var result = await _encina.Send(command!);

    return await result.ToCreatedResponse(req, order => $"/orders/{order.Id}");
}
```

**Core Components**:

| Component | Purpose |
|-----------|---------|
| `EncinaAzureFunctionsOptions` | Configuration for headers, claims, error handling |
| `EncinaFunctionMiddleware` | Request context enrichment middleware |
| `FunctionContextExtensions` | Context extraction (correlation, user, tenant) |
| `HttpResponseDataExtensions` | Result-to-response conversion with ROP |
| `AzureFunctionsHealthCheck` | Health check implementation |
| `ServiceCollectionExtensions` | DI registration |

**HTTP Response Extensions**:
- `ToHttpResponseData<T>()` - Standard response conversion
- `ToCreatedResponse<T>()` - 201 Created with Location header
- `ToNoContentResponse()` - 204 No Content for void operations
- `ToProblemDetailsResponse()` - RFC 7807 Problem Details

**Error Code to HTTP Status Mapping**:

| Error Pattern | HTTP Status |
|--------------|-------------|
| `validation.*` | 400 Bad Request |
| `encina.guard.validation_failed` | 400 Bad Request |
| `authorization.unauthenticated` | 401 Unauthorized |
| `authorization.*` | 403 Forbidden |
| `*.not_found`, `*.missing` | 404 Not Found |
| `*.conflict`, `*.already_exists`, `*.duplicate` | 409 Conflict |
| Other | 500 Internal Server Error |

**Request Context Enrichment**:
- Automatic correlation ID extraction/generation
- User ID extraction from claims
- Tenant ID extraction from headers or claims
- All accessible via `FunctionContext` extensions

**Configuration Options**:

| Option | Default | Description |
|--------|---------|-------------|
| `EnableRequestContextEnrichment` | true | Toggle context enrichment |
| `CorrelationIdHeader` | X-Correlation-ID | Header name for correlation |
| `TenantIdHeader` | X-Tenant-ID | Header name for tenant |
| `UserIdClaimType` | NameIdentifier | Claim type for user ID |
| `TenantIdClaimType` | tenant_id | Claim type for tenant |
| `IncludeExceptionDetailsInResponse` | false | Include details in errors |
| `ProviderHealthCheck.Enabled` | true | Enable health check |

**Test Coverage**:

| Type | Count | Description |
|------|:-----:|-------------|
| Unit Tests | 57 | Options, ServiceCollection, HealthCheck, Extensions |
| Contract Tests | 12 | IEncinaHealthCheck contract |
| Property Tests | 13 | Error code mapping invariants |
| Guard Clause Tests | 8 | Null argument validation |
| Benchmarks | 10 | Error code mapping performance |
| **Total** | **100** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: Would require Azure Functions host, actual Azure resources, or complex mocking. The middleware is a thin wrapper that delegates to Azure Functions infrastructure.
- **Load Tests**: N/A - Azure Functions scaling is handled by the platform, not our code.

**Files Created**:
- `src/Encina.AzureFunctions/Encina.AzureFunctions.csproj`
- `src/Encina.AzureFunctions/EncinaAzureFunctionsOptions.cs`
- `src/Encina.AzureFunctions/ServiceCollectionExtensions.cs`
- `src/Encina.AzureFunctions/FunctionsWorkerApplicationBuilderExtensions.cs`
- `src/Encina.AzureFunctions/EncinaFunctionMiddleware.cs`
- `src/Encina.AzureFunctions/FunctionContextExtensions.cs`
- `src/Encina.AzureFunctions/HttpResponseDataExtensions.cs`
- `src/Encina.AzureFunctions/Log.cs`
- `src/Encina.AzureFunctions/Health/AzureFunctionsHealthCheck.cs`
- `src/Encina.AzureFunctions/GlobalSuppressions.cs`
- `src/Encina.AzureFunctions/PublicAPI.Shipped.txt`
- `src/Encina.AzureFunctions/PublicAPI.Unshipped.txt`
- `src/Encina.AzureFunctions/README.md`
- `tests/Encina.AzureFunctions.Tests/Encina.AzureFunctions.Tests.csproj`
- `tests/Encina.AzureFunctions.Tests/EncinaAzureFunctionsOptionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/ServiceCollectionExtensionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/AzureFunctionsHealthCheckTests.cs`
- `tests/Encina.AzureFunctions.Tests/HttpResponseDataExtensionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/GlobalSuppressions.cs`
- `tests/Encina.AzureFunctions.ContractTests/Encina.AzureFunctions.ContractTests.csproj`
- `tests/Encina.AzureFunctions.ContractTests/HealthCheckContractTests.cs`
- `tests/Encina.AzureFunctions.PropertyTests/Encina.AzureFunctions.PropertyTests.csproj`
- `tests/Encina.AzureFunctions.PropertyTests/ErrorCodeMappingProperties.cs`
- `tests/Encina.AzureFunctions.GuardTests/Encina.AzureFunctions.GuardTests.csproj`
- `tests/Encina.AzureFunctions.GuardTests/GuardClauseTests.cs`
- `benchmarks/Encina.AzureFunctions.Benchmarks/Encina.AzureFunctions.Benchmarks.csproj`
- `benchmarks/Encina.AzureFunctions.Benchmarks/ErrorCodeMappingBenchmarks.cs`
- `benchmarks/Encina.AzureFunctions.Benchmarks/Program.cs`

**Files Modified**:
- `Directory.Packages.props` - Added Azure Functions Worker package versions
- `CHANGELOG.md` - Added Azure Functions integration entry

### December 27 (Continued) - AWS Lambda Integration (Issue #60)

**Issue Closed**: `#60` (AWS Lambda Integration)

**Encina.AwsLambda Package** - AWS Lambda integration with Railway Oriented Programming support:

| Component | Purpose |
|-----------|---------|
| `EncinaAwsLambdaOptions` | Configuration for context enrichment, header names, claim types |
| `ServiceCollectionExtensions` | DI registration via `AddEncinaAwsLambda()` |
| `ApiGatewayResponseExtensions` | Convert `Either<EncinaError, T>` to API Gateway responses |
| `SqsMessageHandler` | Process SQS batches with partial failure reporting |
| `EventBridgeHandler` | Process EventBridge events with automatic deserialization |
| `LambdaContextExtensions` | Extract correlation ID, user ID, tenant ID from context |
| `AwsLambdaHealthCheck` | Health check implementing `IEncinaHealthCheck` |

**API Gateway Response Extensions**:

| Method | Purpose |
|--------|---------|
| `ToApiGatewayResponse<T>()` | 200 OK with JSON body |
| `ToCreatedResponse<T>()` | 201 Created with Location header |
| `ToNoContentResponse()` | 204 No Content |
| `ToHttpApiResponse<T>()` | HTTP API (V2) format |
| `ToProblemDetailsResponse()` | RFC 7807 error response |

**Error Code to HTTP Status Mapping**:

| Error Code Pattern | HTTP Status |
|-------------------|-------------|
| `validation.*` | 400 Bad Request |
| `authorization.unauthenticated` | 401 Unauthorized |
| `authorization.*` | 403 Forbidden |
| `*.not_found`, `*.missing` | 404 Not Found |
| `*.conflict`, `*.already_exists`, `*.duplicate` | 409 Conflict |
| (default) | 500 Internal Server Error |

**SQS Message Handler**:

| Method | Purpose |
|--------|---------|
| `ProcessBatchAsync<TMessage, TResult>()` | Process with automatic deserialization and partial failure reporting |
| `ProcessBatchAsync()` | Process raw SQS records with partial failure reporting |
| `ProcessAllAsync()` | Process all-or-nothing (stops on first error) |
| `DeserializeMessage<T>()` | Type-safe message deserialization |

**EventBridge Handler**:

| Method | Purpose |
|--------|---------|
| `ProcessAsync<TDetail, TResult>()` | Strongly-typed event processing |
| `ProcessRawAsync<TDetail, TResult>()` | Process from raw JSON |
| `GetMetadata()` | Extract event metadata |

**Lambda Context Extensions**:

| Method | Purpose |
|--------|---------|
| `GetCorrelationId()` | From header or AWS Request ID |
| `GetUserId()` | From JWT claims |
| `GetTenantId()` | From header or claims |
| `GetAwsRequestId()` | AWS Request ID |
| `GetFunctionName()` | Function name |
| `GetRemainingTimeMs()` | Remaining execution time |

**Test Coverage**:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Unit Tests | 97 | Core functionality |
| Contract Tests | 21 | API behavior contracts |
| Property Tests | 10 | Invariant validation |
| Guard Tests | 21 | Null parameter validation |
| Benchmarks | 6 | Response creation performance |
| **Total** | **155** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: Would require AWS Lambda runtime, LocalStack, or complex mocking. The handlers are thin wrappers over AWS SDK types.
- **Load Tests**: N/A - AWS Lambda scaling is handled by the platform, not our code.

**Files Created**:
- `src/Encina.AwsLambda/Encina.AwsLambda.csproj`
- `src/Encina.AwsLambda/EncinaAwsLambdaOptions.cs`
- `src/Encina.AwsLambda/ServiceCollectionExtensions.cs`
- `src/Encina.AwsLambda/ApiGatewayResponseExtensions.cs`
- `src/Encina.AwsLambda/SqsMessageHandler.cs`
- `src/Encina.AwsLambda/EventBridgeHandler.cs`
- `src/Encina.AwsLambda/LambdaContextExtensions.cs`
- `src/Encina.AwsLambda/Health/AwsLambdaHealthCheck.cs`
- `src/Encina.AwsLambda/GlobalSuppressions.cs`
- `src/Encina.AwsLambda/PublicAPI.Shipped.txt`
- `src/Encina.AwsLambda/PublicAPI.Unshipped.txt`
- `src/Encina.AwsLambda/README.md`
- `tests/Encina.AwsLambda.Tests/Encina.AwsLambda.Tests.csproj`
- `tests/Encina.AwsLambda.Tests/EncinaAwsLambdaOptionsTests.cs`
- `tests/Encina.AwsLambda.Tests/ServiceCollectionExtensionsTests.cs`
- `tests/Encina.AwsLambda.Tests/ApiGatewayResponseExtensionsTests.cs`
- `tests/Encina.AwsLambda.Tests/SqsMessageHandlerTests.cs`
- `tests/Encina.AwsLambda.Tests/EventBridgeHandlerTests.cs`
- `tests/Encina.AwsLambda.Tests/LambdaContextExtensionsTests.cs`
- `tests/Encina.AwsLambda.Tests/AwsLambdaHealthCheckTests.cs`
- `tests/Encina.AwsLambda.ContractTests/Encina.AwsLambda.ContractTests.csproj`
- `tests/Encina.AwsLambda.ContractTests/ApiGatewayResponseContractTests.cs`
- `tests/Encina.AwsLambda.ContractTests/SqsHandlerContractTests.cs`
- `tests/Encina.AwsLambda.PropertyTests/Encina.AwsLambda.PropertyTests.csproj`
- `tests/Encina.AwsLambda.PropertyTests/ErrorCodeMappingProperties.cs`
- `tests/Encina.AwsLambda.GuardTests/Encina.AwsLambda.GuardTests.csproj`
- `tests/Encina.AwsLambda.GuardTests/GuardClauseTests.cs`
- `benchmarks/Encina.AwsLambda.Benchmarks/Encina.AwsLambda.Benchmarks.csproj`
- `benchmarks/Encina.AwsLambda.Benchmarks/ApiGatewayResponseBenchmarks.cs`
- `benchmarks/Encina.AwsLambda.Benchmarks/Program.cs`

**Files Modified**:
- `Directory.Packages.props` - Added AWS Lambda Core and Events package versions
- `CHANGELOG.md` - Added AWS Lambda integration entry
- `ROADMAP.md` - Updated serverless section to show AWS Lambda as complete

---

### December 27 - Durable Functions Integration (Issue #61)

**Issue Closed**: `#61`

**Durable Functions Integration** (Encina.AzureFunctions.Durable):

Added Azure Durable Functions support with Railway Oriented Programming (ROP) integration.

**Orchestration Context Extensions**:
- `CallEncinaActivityAsync<TInput, TResult>()` for calling activities that return Either directly
- `CallEncinaActivityWithResultAsync<TInput, TResult>()` for activities using ActivityResult wrapper
- `CallEncinaSubOrchestratorAsync<TInput, TResult>()` for sub-orchestrator calls with Either
- `WaitForEncinaExternalEventAsync<T>()` for waiting on external events with timeout and ROP result
- `CreateRetryOptions()` for creating TaskOptions from retry parameters
- `GetCorrelationId()` for accessing orchestration instance ID as correlation ID

**ActivityResult<T> Serializable Wrapper**:
- Serializable wrapper for Either results (Durable Functions require JSON serialization)
- `Success()` and `Failure()` factory methods
- `ToEither()` for conversion back to Either
- `ToActivityResult()` extension for Either conversion to ActivityResult

**Saga Pattern with DurableSagaBuilder**:
- `DurableSagaBuilder<TData>` fluent API for defining saga workflows
- `DurableSagaStepBuilder<TData>` for configuring individual steps
- `Step()` for adding named steps
- `Execute()` for setting activity name
- `Compensate()` for setting compensation activity
- `WithRetry()` for step-level retry configuration
- `SkipCompensationOnFailure()` for idempotent operations
- `WithTimeout()` for saga-level timeout
- `WithDefaultRetryOptions()` for default retry options across all steps
- Automatic compensation in reverse order on failure
- `DurableSaga<TData>.ExecuteAsync()` for execution
- `DurableSagaError` capturing original error and compensation results

**Fan-Out/Fan-In Extensions**:
- `FanOutAsync<TInput, TResult>()` for parallel activity execution with all results
- `FanOutAllAsync<TInput, TResult>()` requiring all parallel executions to succeed
- `FanOutFirstSuccessAsync<TInput, TResult>()` returning first successful result
- `FanOutMultipleAsync<T1, T2>()` for running different activities in parallel
- `Partition<T>()` for separating successes from failures in result collections

**Configuration & Health Check**:
- `DurableFunctionsOptions` for configuring defaults:
  - `DefaultMaxRetries`, `DefaultFirstRetryInterval`, `DefaultBackoffCoefficient`, `DefaultMaxRetryInterval`
  - `ContinueCompensationOnError`, `DefaultSagaTimeout`
  - `ProviderHealthCheck` options
- `DurableFunctionsHealthCheck` implementing `IEncinaHealthCheck`
- DI registration via `AddEncinaDurableFunctions()`

**Test Coverage**:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Unit | 124 | Core functionality |
| Contract | 58 | API contract verification |
| Property | 27 | Invariant verification |
| Guard | 19 | Null/argument validation |
| **Total** | **228** | Comprehensive coverage |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: Would require Azure Durable Task runtime or emulator
- **Load Tests**: N/A - Durable Functions scaling is handled by the platform

**Files Created**:
- `src/Encina.AzureFunctions/Durable/OrchestrationContextExtensions.cs`
- `src/Encina.AzureFunctions/Durable/ActivityResult.cs`
- `src/Encina.AzureFunctions/Durable/DurableSagaBuilder.cs`
- `src/Encina.AzureFunctions/Durable/FanOutFanInExtensions.cs`
- `src/Encina.AzureFunctions/Durable/DurableFunctionsOptions.cs`
- `src/Encina.AzureFunctions/Durable/DurableFunctionsHealthCheck.cs`
- `src/Encina.AzureFunctions/Durable/DurableServiceCollectionExtensions.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/ActivityResultTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/DurableFunctionsOptionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/DurableFunctionsHealthCheckTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/DurableSagaBuilderTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/DurableServiceCollectionExtensionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/OrchestrationContextExtensionsTests.cs`
- `tests/Encina.AzureFunctions.Tests/Durable/FanOutFanInExtensionsTests.cs`
- `tests/Encina.AzureFunctions.ContractTests/Durable/DurableFunctionsHealthCheckContractTests.cs`
- `tests/Encina.AzureFunctions.ContractTests/Durable/ActivityResultContractTests.cs`
- `tests/Encina.AzureFunctions.ContractTests/Durable/DurableSagaBuilderContractTests.cs`
- `tests/Encina.AzureFunctions.ContractTests/Durable/DurableServiceCollectionContractTests.cs`
- `tests/Encina.AzureFunctions.PropertyTests/Durable/ActivityResultProperties.cs`
- `tests/Encina.AzureFunctions.PropertyTests/Durable/DurableSagaBuilderProperties.cs`
- `tests/Encina.AzureFunctions.GuardTests/Durable/DurableFunctionsGuardClauseTests.cs`

**Files Modified**:
- `Directory.Packages.props` - Added Microsoft.Azure.Functions.Worker.Extensions.DurableTask
- `src/Encina.AzureFunctions/Encina.AzureFunctions.csproj` - Added DurableTask package reference
- `src/Encina.AzureFunctions/GlobalSuppressions.cs` - Added CA1000 suppression for ActivityResult<T>
- `src/Encina.AzureFunctions/PublicAPI.Unshipped.txt` - Added all new Durable symbols
- `src/Encina.AzureFunctions/README.md` - Added Durable Functions documentation
- `CHANGELOG.md` - Added Durable Functions integration entry
- `tests/Encina.AzureFunctions.ContractTests/Encina.AzureFunctions.ContractTests.csproj` - Added packages
- `tests/Encina.AzureFunctions.PropertyTests/Encina.AzureFunctions.PropertyTests.csproj` - Added packages

---

### December 27 - Module-scoped Pipeline Behaviors

**Issue Closed**: `#58`

**Module-scoped Pipeline Behaviors** for modular monolith architectures:

Implemented the ability for pipeline behaviors to be scoped to specific modules, ensuring they only execute when the request is handled by handlers within that module.

**Core Interface**:
- `IModulePipelineBehavior<TModule, TRequest, TResponse>` - Marker interface for module-specific behaviors
- Same signature as `IPipelineBehavior` but with TModule type parameter for module association

**ModuleBehaviorAdapter**:
- Internal adapter that wraps `IModulePipelineBehavior` implementations
- Filters execution based on handler-module ownership
- Uses `IModuleHandlerRegistry` to determine if handler belongs to target module
- Skips behavior execution (passes directly to next step) if handler is not in target module

**IModuleHandlerRegistry**:
- Maps handler types to their owning modules via assembly association
- `GetModuleName(Type handlerType)` - Returns module name for a handler type
- `GetModule(Type handlerType)` - Returns module instance for a handler type
- `BelongsToModule(Type handlerType, string moduleName)` - Case-insensitive module membership check
- `BelongsToModule<TModule>(Type handlerType)` - Generic module membership check
- `NullModuleHandlerRegistry` - Null Object pattern for when modules aren't configured

**Request Context Extensions**:
- `GetModuleName()` - Retrieves current module name from context metadata
- `WithModuleName(string name)` - Sets module name in context (immutable, returns new context)
- `WithModuleName(IModule module)` - Sets module name from module instance
- `IsInModule(string moduleName)` - Case-insensitive check if context is in module
- `IsInModule<TModule>(TModule module)` - Generic check if context is in module

**DI Extension Methods**:
- `AddEncinaModuleBehavior<TModule, TRequest, TResponse, TBehavior>()` - Registers module behavior
- Overload with `ServiceLifetime` parameter for custom lifetimes (Scoped default)
- Automatically registers behavior implementation, interface, and adapter

**Assembly Scanner Fix**:
- Skip `ModuleBehaviorAdapter` during assembly scanning (3 type params vs 2 for IPipelineBehavior)
- Prevents arity mismatch error when scanning Encina assembly

**Test Coverage**:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Unit | 100 | Core functionality for all module components |

**Why Some Test Types Don't Apply**:
- **Integration Tests**: Module behaviors are tested in isolation; integration with real Encina pipeline is covered by unit tests with mocks
- **Property Tests**: Module behavior filtering is deterministic based on registry state
- **Load Tests**: N/A - Module filtering is a simple boolean check
- **Benchmarks**: N/A - Module filtering adds negligible overhead (single dictionary lookup)

**Files Created**:
- `src/Encina/Modules/IModulePipelineBehavior.cs`
- `src/Encina/Modules/ModuleBehaviorAdapter.cs`
- `src/Encina/Modules/IModuleHandlerRegistry.cs`
- `src/Encina/Modules/ModuleHandlerRegistry.cs`
- `src/Encina/Modules/RequestContextModuleExtensions.cs`
- `src/Encina/Modules/ModuleBehaviorServiceCollectionExtensions.cs`
- `tests/Encina.Tests/Modules/ModuleBehaviorAdapterTests.cs`
- `tests/Encina.Tests/Modules/ModuleHandlerRegistryTests.cs`
- `tests/Encina.Tests/Modules/RequestContextModuleExtensionsTests.cs`
- `tests/Encina.Tests/Modules/ModuleBehaviorServiceCollectionExtensionsTests.cs`

**Files Modified**:
- `src/Encina/Modules/ModuleServiceCollectionExtensions.cs` - Added IModuleHandlerRegistry registration
- `src/Encina/Core/ServiceCollectionExtensions.cs` - Added NullModuleHandlerRegistry fallback
- `src/Encina/Dispatchers/MediatorAssemblyScanner.cs` - Skip ModuleBehaviorAdapter during scanning
- `src/Encina/PublicAPI.Unshipped.txt` - Added all new public API symbols
- `CHANGELOG.md` - Added module-scoped behaviors entry
- `ROADMAP.md` - Added Module-scoped behaviors to Phase 2 completed items

---

### December 27 (Continued) - Distributed Lock Abstractions (Issue #55)

**Issue Closed**: `#55`

**Distributed Lock Abstractions** provides a provider-agnostic distributed locking system for coordinating access to shared resources across multiple processes or machines.

**Core Abstractions Package (Encina.DistributedLock)**:

| Interface/Class | Purpose |
|-----------------|---------|
| `IDistributedLockProvider` | Main provider interface with TryAcquire, Acquire, IsLocked, Extend |
| `ILockHandle` | Lock handle with Resource, AcquiredAtUtc, ExpiresAtUtc, ReleaseAsync |
| `DistributedLockOptions` | Base options with DefaultExpiry, DefaultWaitTime, DefaultRetryInterval |
| `LockAcquisitionException` | Exception for failed lock acquisitions |

**Provider Implementations**:

| Package | Backend | Use Case |
|---------|---------|----------|
| `Encina.DistributedLock.InMemory` | ConcurrentDictionary | Testing & single-instance apps |
| `Encina.DistributedLock.Redis` | StackExchange.Redis with Lua scripts | Production distributed systems |
| `Encina.DistributedLock.SqlServer` | sp_getapplock stored procedure | Database-centric applications |

**Key Design Decisions**:

1. **Safe Lock Release**: Redis implementation uses Lua scripts to ensure only the lock owner can release
2. **Lock Extension**: All providers support extending lock expiry without re-acquiring
3. **Health Checks**: Redis and SQL Server providers include ASP.NET Core health checks
4. **ROP Integration**: Lock acquisition returns `null` on timeout instead of throwing (TryAcquire pattern)

**Redis Implementation Details**:
- Uses SET NX EX for atomic lock acquisition with expiry
- Lua script for safe release (verifies ownership via unique lock value)
- Lock value includes hostname + GUID for debugging
- Health check verifies Redis connectivity

**SQL Server Implementation Details**:
- Uses sp_getapplock with TRANSACTION scope
- Requires SqlConnection with active transaction
- Lock is auto-released when transaction commits/rolls back
- Health check verifies database connectivity

**Encina.Caching Integration**:
- Updated `Encina.Caching` to reference `Encina.DistributedLock`
- Re-exports types via global using alias for backward compatibility
- `IDistributedLockProvider` now comes from dedicated package

**Test Coverage**:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Unit | 100+ | Provider functionality, DI registration, options |
| Integration | 50+ | Testcontainers with real Redis/SQL Server |
| Contract | 20+ | Interface contract verification across providers |
| Property | 30+ | FsCheck invariants for locking behavior |
| Guard | 30+ | ArgumentNullException verification |
| Load | 10+ | High-concurrency stress tests |
| Benchmark | 5+ | BenchmarkDotNet performance measurement |

**Files Created**:

Core Package:
- `src/Encina.DistributedLock/IDistributedLockProvider.cs`
- `src/Encina.DistributedLock/ILockHandle.cs`
- `src/Encina.DistributedLock/DistributedLockOptions.cs`
- `src/Encina.DistributedLock/LockAcquisitionException.cs`
- `src/Encina.DistributedLock/ServiceCollectionExtensions.cs`
- `src/Encina.DistributedLock/README.md`

InMemory Provider:
- `src/Encina.DistributedLock.InMemory/InMemoryDistributedLockProvider.cs`
- `src/Encina.DistributedLock.InMemory/InMemoryLockOptions.cs`
- `src/Encina.DistributedLock.InMemory/InMemoryLockHandle.cs`
- `src/Encina.DistributedLock.InMemory/ServiceCollectionExtensions.cs`

Redis Provider:
- `src/Encina.DistributedLock.Redis/RedisDistributedLockProvider.cs`
- `src/Encina.DistributedLock.Redis/RedisLockOptions.cs`
- `src/Encina.DistributedLock.Redis/RedisLockHandle.cs`
- `src/Encina.DistributedLock.Redis/Health/RedisDistributedLockHealthCheck.cs`
- `src/Encina.DistributedLock.Redis/ServiceCollectionExtensions.cs`

SQL Server Provider:
- `src/Encina.DistributedLock.SqlServer/SqlServerDistributedLockProvider.cs`
- `src/Encina.DistributedLock.SqlServer/SqlServerLockOptions.cs`
- `src/Encina.DistributedLock.SqlServer/SqlServerLockHandle.cs`
- `src/Encina.DistributedLock.SqlServer/Health/SqlServerDistributedLockHealthCheck.cs`
- `src/Encina.DistributedLock.SqlServer/ServiceCollectionExtensions.cs`

Test Projects:
- `tests/Encina.DistributedLock.Tests/`
- `tests/Encina.DistributedLock.Redis.Tests/`
- `tests/Encina.DistributedLock.SqlServer.Tests/`
- `tests/Encina.DistributedLock.ContractTests/`
- `tests/Encina.DistributedLock.PropertyTests/`
- `tests/Encina.DistributedLock.GuardTests/`
- `tests/Encina.DistributedLock.IntegrationTests/`
- `tests/Encina.DistributedLock.LoadTests/`
- `benchmarks/Encina.DistributedLock.Benchmarks/`

**Files Modified**:
- `src/Encina.Caching/Encina.Caching.csproj` - Added Encina.DistributedLock reference
- `src/Encina.Caching/Abstractions/IDistributedLockProvider.cs` - Re-exports from new package
- `Encina.slnx` - Added all new projects
- `CHANGELOG.md` - Added distributed lock entry
- `ROADMAP.md` - Updated Phase 2 status

---

### December 27 (Afternoon) - Content-Based Router (Issue #64)

**Overview**:
Implemented the Content-Based Router Enterprise Integration Pattern (EIP), which routes messages to handlers based on message content inspection.

**Core Abstractions**:

`IContentRouter` interface:
```csharp
public interface IContentRouter
{
    ValueTask<Either<EncinaError, ContentRouterResult<TResult>>> RouteAsync<TMessage, TResult>(
        BuiltContentRouterDefinition<TMessage, TResult> definition,
        TMessage message,
        CancellationToken cancellationToken = default)
        where TMessage : class;
}
```

**Fluent Builder API**:

`ContentRouterBuilder` provides a fluent API for defining routing rules:
- `When(condition)` / `When(name, condition)` - Add conditional routes
- `RouteTo(handler)` - Configure handler (sync/async, with/without Either)
- `WithPriority(int)` - Set route priority (lower = higher priority)
- `WithMetadata(key, value)` - Add route metadata
- `Default(handler)` - Fallback route when no conditions match

Example:
```csharp
var definition = ContentRouterBuilder.Create<Order, string>()
    .When("HighValue", o => o.Total > 10000)
        .WithPriority(1)
        .RouteTo(async (o, ct) => await ProcessHighValueOrder(o, ct))
    .When("International", o => o.IsInternational)
        .WithPriority(2)
        .RouteTo(o => Right<EncinaError, string>("InternationalHandler"))
    .Default(o => Right<EncinaError, string>("StandardHandler"))
    .Build();

var result = await router.RouteAsync(definition, order);
```

**Configuration Options**:

`ContentRouterOptions`:
- `ThrowOnNoMatch` (default: true) - Return error when no route matches
- `AllowMultipleMatches` (default: false) - Execute all matching routes
- `EvaluateInParallel` (default: false) - Parallel route execution
- `MaxDegreeOfParallelism` (default: Environment.ProcessorCount) - Concurrency limit

**DI Integration**:

```csharp
services.AddEncinaMessaging(config =>
{
    config.UseContentRouter = true;
    config.ContentRouterOptions.ThrowOnNoMatch = true;
    config.ContentRouterOptions.AllowMultipleMatches = false;
});
```

**Test Coverage**:

| Test Type | Count | Purpose |
|-----------|-------|---------|
| Unit | 45 | Router and builder functionality |
| Integration | 6 | DI container, scoped services, concurrency |
| Contract | 15 | Interface contract verification |
| Property | 12 | FsCheck invariants for routing behavior |
| Guard | 25 | ArgumentNullException verification |
| Load | 7 | High-concurrency stress tests |
| Benchmark | 4 | BenchmarkDotNet performance measurement |

**Total**: 117 tests

**Files Created**:

ContentRouter Package:
- `src/Encina.Messaging/ContentRouter/IContentRouter.cs`
- `src/Encina.Messaging/ContentRouter/ContentRouter.cs`
- `src/Encina.Messaging/ContentRouter/ContentRouterBuilder.cs`
- `src/Encina.Messaging/ContentRouter/ContentRouterOptions.cs`
- `src/Encina.Messaging/ContentRouter/ContentRouterResult.cs`
- `src/Encina.Messaging/ContentRouter/RouteDefinition.cs`
- `src/Encina.Messaging/ContentRouter/ContentRouterErrorCodes.cs`

Test Files:
- `tests/Encina.Tests/ContentRouter/ContentRouterTests.cs`
- `tests/Encina.Tests/ContentRouter/ContentRouterBuilderTests.cs`
- `tests/Encina.Tests/Guards/ContentRouterGuardsTests.cs`
- `tests/Encina.Tests/PropertyTests/ContentRouterPropertyTests.cs`
- `tests/Encina.Tests/Contracts/ContentRouterContractTests.cs`
- `tests/Encina.Tests/Integration/ContentRouterIntegrationTests.cs`
- `tests/Encina.Tests/LoadTests/ContentRouterLoadTests.cs`
- `benchmarks/Encina.Benchmarks/ContentRouterBenchmarks.cs`

**Files Modified**:
- `src/Encina.Messaging/MessagingConfiguration.cs` - Added `UseContentRouter` flag
- `src/Encina.Messaging/MessagingServiceCollectionExtensions.cs` - Added DI registration
- `CHANGELOG.md` - Added Content-Based Router entry
- `ROADMAP.md` - Updated Phase 2 status

---

*Last Updated: 2025-12-27*
